mod config;
mod users;
mod util;
mod api;
mod templates;
mod wizard;
mod instances;

use askama::Template;
use axum::{
    extract::{Form, State},
    response::{Html, IntoResponse, Redirect, Response},
    routing::{get, post},
    Router,
};
use tower_http::services::ServeDir;
use tower_http::set_header::SetResponseHeaderLayer;
use axum::http::header::CACHE_CONTROL;
use axum::http::HeaderValue;
use tower::ServiceBuilder;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::net::SocketAddr;
use std::sync::{Arc, Mutex};
use std::collections::HashMap;
use std::process;
use clap::{Parser, Subcommand};
use tracing_subscriber::{fmt, EnvFilter};
use tracing_subscriber::layer::SubscriberExt;
use tracing_subscriber::util::SubscriberInitExt;
use axum_extra::extract::cookie::{CookieJar, Cookie};

use config::{DEFAULT_HOST, DEFAULT_PORT};
use users::{UserRecord, CurrentUser, generate_password_hash, verify_password, random_session_id, load_users_from_file, persist_users_file};
use util::{hostname_from_url, absolute_url, build_query_string, parse_flag, parse_optional_int, parse_int_list};
use api::{api_call, load_regions, load_products, load_os_list, load_applications, load_instances_for_user, Region, ProductView, OsItem, ApplicationView, InstanceView};
use instances::{AppState, simple_instance_action, enforce_instance_access, get_instance_for_action, AddTrafficForm, ChangeOsForm, ResizeForm};
use wizard::{parse_wizard_base, build_base_query_pairs, BaseState, Step1FormData, Step2FormData, CustomPlanFormValues, Step7Form};
use templates::*;
use urlencoding::encode;
// No-op logging ignore endpoint list
static LOGGING_IGNORE_ENDPOINTS: &[&str] = &["/v1/os", "/v1/products", "/os", "/products"];

#[derive(Deserialize, Debug)]
#[serde(untagged)]
enum OneOrMany {
    One(String),
    Many(Vec<String>),
}

impl OneOrMany {
    fn to_csv(self) -> String {
        match self {
            OneOrMany::One(s) => s,
            OneOrMany::Many(v) => v.join(","),
        }
    }
}

fn build_state_from_env(env_file: Option<&str>) -> AppState {
    config::load_env_file(env_file);
    let users = load_users_from_file();
    let disabled_instances = std::sync::Arc::new(config::get_disabled_instance_ids());
    
    AppState {
        users,
        sessions: Arc::new(Mutex::new(HashMap::new())),
        flash_store: Arc::new(Mutex::new(HashMap::new())),
        default_customer_cache: Arc::new(Mutex::new(None)),
        api_base_url: config::get_api_base_url(),
        api_token: config::get_api_token(),
        public_base_url: config::get_public_base_url(),
        client: reqwest::Client::new(),
        disabled_instances,
    }
}

// Global template context injected into most page templates
// (already implemented via build_template_globals/TemplateGlobals)
#[derive(Template)]
#[template(path = "regions.html")]
struct RegionsPageTemplate<'a> {
    current_user: Option<CurrentUser>,
    api_hostname: String,
    base_url: String,
    flash_messages: Vec<String>,
    has_flash_messages: bool,
    regions: &'a [Region],
}

#[derive(Template)]
#[template(path = "products.html")]
struct ProductsPageTemplate<'a> {
    current_user: Option<CurrentUser>,
    api_hostname: String,
    base_url: String,
    flash_messages: Vec<String>,
    has_flash_messages: bool,
    regions: &'a [Region],
    selected_region: Option<&'a Region>,
    active_region_id: String,
    requested_region: Option<String>,
    products: &'a [ProductView],
}

#[derive(Template)]
#[template(path = "os.html")]
struct OsCatalogTemplate<'a> {
    current_user: Option<CurrentUser>,
    api_hostname: String,
    base_url: String,
    flash_messages: Vec<String>,
    has_flash_messages: bool,
    os_list: &'a [OsItem],
}

#[derive(Template)]
#[template(path = "applications.html")]
struct ApplicationsTemplate<'a> {
    current_user: Option<CurrentUser>,
    api_hostname: String,
    base_url: String,
    flash_messages: Vec<String>,
    has_flash_messages: bool,
    apps: &'a [ApplicationView],
}

#[derive(Template)]
#[template(path = "instance_detail.html")]
struct InstanceDetailTemplate {
    current_user: Option<CurrentUser>,
    api_hostname: String,
    base_url: String,
    flash_messages: Vec<String>,
    has_flash_messages: bool,
    instance_id: String,
    hostname: String,
    details: Vec<(String, String)>,
    is_disabled: bool,
}

#[derive(Template)]
#[template(path = "bulk_refund.html")]
struct BulkRefundTemplate {
    current_user: Option<CurrentUser>,
    api_hostname: String,
    base_url: String,
    flash_messages: Vec<String>,
    has_flash_messages: bool,
}

fn build_app(state: AppState) -> Router {
    Router::new()
        .route("/", get(root_get))
        .route("/login", get(login_get).post(login_post))
        .route("/logout", post(logout_post))
        .route("/users", get(users_list).post(users_create))
        .route("/users/:username/reset-password", post(reset_password))
        .route("/users/:username/role", post(update_role))
        .route("/users/:username/delete", post(delete_user))
        .route("/access", get(access_get))
        .route("/access/:username", post(update_access))
        .route("/ssh-keys", get(ssh_keys_get).post(ssh_keys_post))
        .route("/instances", get(instances_real))
        .route("/regions", get(regions_get))
        .route("/products", get(products_get))
        .route("/os", get(os_get))
        .route("/applications", get(applications_get))
        .route("/create/step-1", get(create_step_1))
        .route("/create/step-2", get(create_step_2))
        .route("/create/step-3", get(create_step_3))
        .route("/create/step-4", get(create_step_4))
        .route("/create/step-5", get(create_step_5))
        .route("/create/step-6", get(create_step_6))
        .route(
            "/create/step-7",
            get(create_step_7_get).post(create_step_7_post),
        )
        .route("/create/result", get(create_step_8))
        .route("/instance/:instance_id", get(instance_detail))
        .route("/instance/:instance_id/delete", get(instance_delete_get).post(instance_delete))
        .route("/instance/:instance_id/poweron", get(instance_poweron_get).post(instance_poweron_post))
        .route("/instance/:instance_id/poweroff", get(instance_poweroff_get).post(instance_poweroff_post))
        .route("/instance/:instance_id/reset", get(instance_reset_get).post(instance_reset_post))
        .route(
            "/instance/:instance_id/change-pass",
            get(instance_change_pass_get).post(instance_change_pass_post),
        )
        .route("/instance/:instance_id/change-os", get(instance_change_os_get).post(instance_change_os_post))
        .route("/instance/:instance_id/resize", get(instance_resize_get).post(instance_resize_post))
        .route(
            "/instance/:instance_id/subscription-refund",
            get(instance_subscription_refund),
        )
        .route(
            "/instance/:instance_id/add-traffic",
            post(instance_add_traffic),
        )
        .route(
            "/bulk-subscription-refund",
            get(bulk_subscription_refund_get).post(bulk_subscription_refund),
        )
        // Serve static files with cache-control header to avoid reloading stylesheets on each request
        .nest_service(
            "/static",
            ServiceBuilder::new()
                .layer(SetResponseHeaderLayer::if_not_present(
                    CACHE_CONTROL,
                    HeaderValue::from_static("public, max-age=31536000, immutable"),
                ))
                .service(ServeDir::new("static")),
        )
        .with_state(state)
}

async fn start_server(state: AppState, host: &str, port: u16) {
    let addr: SocketAddr = format!("{}:{}", host, port).parse().unwrap();
    let app = build_app(state.clone());
    tracing::info!(%addr, "Starting Zyffiliate Rust server");
    match tokio::net::TcpListener::bind(addr).await {
        Ok(listener) => {
            // Run the server and log any errors (do not panic with unwrap()).
            if let Err(e) = axum::serve(listener, app).await {
                tracing::error!(%e, "Server encountered an error while running");
                eprintln!("Server error: {}", e);
                process::exit(1);
            }
        }
        Err(e) => {
            tracing::error!(%e, "Failed to bind to address; is the port already in use?");
            eprintln!("Failed to bind to {}: {}\nPlease stop any process using this port, or start the server with a different --port value.", addr, e);
            process::exit(1);
        }
    }
}

// Individual route handlers (stubs). Later these will load data & real templates.
#[derive(Deserialize)]
struct LoginForm {
    username: String,
    password: String,
}

#[derive(Template)]
#[template(path = "login.html")]
struct LoginTemplate {
    current_user: Option<CurrentUser>,
    api_hostname: String,
    base_url: String,
    flash_messages: Vec<String>,
    has_flash_messages: bool,
    error: Option<String>,
}

async fn login_get(State(state): State<AppState>, jar: CookieJar) -> impl IntoResponse {
    if let Some(_username) = current_username_from_jar(&state, &jar) {
        // If already logged in, redirect to `/` which will then send the
        // user to the correct default landing (instances or create).
        return Redirect::to("/").into_response();
    }
    let TemplateGlobals {
        current_user,
        api_hostname,
        base_url,
        flash_messages,
        has_flash_messages,
    } = build_template_globals(&state, &jar);
    inject_context(
        &state,
        &jar,
        LoginTemplate {
            current_user,
            api_hostname,
            base_url: base_url.clone(),
            flash_messages,
            has_flash_messages,
            error: None,
        }
        .render()
        .unwrap(),
    )
}

async fn login_post(
    State(state): State<AppState>,
    jar: CookieJar,
    Form(form): Form<LoginForm>,
) -> impl IntoResponse {
    let uname = form.username.trim().to_lowercase();
    let users = state.users.lock().unwrap();
    if let Some(record) = users.get(&uname) {
        if verify_password(&record.password, &form.password) {
            drop(users);
            let sid = random_session_id();
            state
                .sessions
                .lock()
                .unwrap()
                .insert(sid.clone(), uname.clone());
            let mut cookie = Cookie::new("session_id", sid);
            cookie.set_path("/");
            cookie.set_http_only(true);
            let target = resolve_default_endpoint(&state, &uname);
            return (jar.add(cookie), Redirect::to(&target)).into_response();
        }
    }
    drop(users);
    let TemplateGlobals {
        current_user,
        api_hostname,
        base_url,
        flash_messages,
        has_flash_messages,
    } = build_template_globals(&state, &jar);
    inject_context(
        &state,
        &jar,
        LoginTemplate {
            current_user,
            api_hostname,
            base_url,
            flash_messages,
            has_flash_messages,
            error: Some("Invalid credentials".into()),
        }
        .render()
        .unwrap(),
    )
}
async fn logout_post(State(state): State<AppState>, jar: CookieJar) -> impl IntoResponse {
    if let Some(sid) = jar.get("session_id").map(|c| c.value().to_string()) {
        state.sessions.lock().unwrap().remove(&sid);
    }
    let cleared = jar.remove(Cookie::new("session_id", ""));
    Redirect::to("/login").into_response_with(cleared)
}

trait IntoResponseWithJar {
    fn into_response_with(self, jar: CookieJar) -> axum::response::Response;
}

impl IntoResponseWithJar for Redirect {
    fn into_response_with(self, jar: CookieJar) -> axum::response::Response {
        (jar, self).into_response()
    }
}

fn current_username_from_jar(state: &AppState, jar: &CookieJar) -> Option<String> {
    let sid = session_id_from_jar(jar)?;
    state.sessions.lock().unwrap().get(&sid).cloned()
}

fn session_id_from_jar(jar: &CookieJar) -> Option<String> {
    jar.get("session_id").map(|c| c.value().to_string())
}

fn take_flash_messages(state: &AppState, jar: &CookieJar) -> Vec<String> {
    let Some(session_id) = session_id_from_jar(jar) else {
        return Vec::new();
    };
    state
        .flash_store
        .lock()
        .unwrap()
        .remove(&session_id)
        .unwrap_or_default()
}

fn resolve_default_endpoint(state: &AppState, username: &str) -> String {
    let users = state.users.lock().unwrap();
    if let Some(user) = users.get(username) {
        if user.role == "owner" {
            return "/create/step-1".to_string();
        }
        return "/instances".to_string();
    }
    "/login".to_string()
}




fn build_current_user(state: &AppState, jar: &CookieJar) -> Option<CurrentUser> {
    let uname = current_username_from_jar(state, jar)?;
    let users = state.users.lock().unwrap();
    let rec = users.get(&uname)?;
    Some(CurrentUser {
        username: uname,
        role: rec.role.clone(),
    })
}

#[derive(Default)]
struct TemplateGlobals {
    current_user: Option<CurrentUser>,
    api_hostname: String,
    base_url: String,
    flash_messages: Vec<String>,
    has_flash_messages: bool,
}

fn build_template_globals(state: &AppState, jar: &CookieJar) -> TemplateGlobals {
    let flash_messages = take_flash_messages(state, jar);
    TemplateGlobals {
        current_user: build_current_user(state, jar),
        api_hostname: hostname_from_url(&state.api_base_url),
        base_url: state.public_base_url.clone(),
        has_flash_messages: !flash_messages.is_empty(),
        flash_messages,
    }
}


fn inject_context(state: &AppState, jar: &CookieJar, mut html: String) -> Response {
    let current = build_current_user(state, jar);
    let api_hostname = hostname_from_url(&state.api_base_url);
    // Insert a hidden context div right after opening <body>
    let ctx_div = format!("<div id='ctx' data-api-hostname='{}' data-base-url='{}' data-current-username='{}' data-current-role='{}' style='display:none'></div>",
                          api_hostname,
                          state.public_base_url,
                          current.as_ref().map(|c| c.username.clone()).unwrap_or_default(),
                          current.as_ref().map(|c| c.role.clone()).unwrap_or_default());
    if let Some(pos) = html.find("<body>") {
        let insert_pos = pos + "<body>".len();
        html.insert_str(insert_pos, &ctx_div);
    } else {
        html.push_str(&ctx_div);
    }
    Html(html).into_response()
}

// ---------- Helper Parsing Functions (Wizard) ----------

fn parse_flag(value: Option<&String>, default: bool) -> bool {
    match value {
        Some(v) => {
            let t = v.trim().to_lowercase();
            if t.is_empty() {
                default
            } else {
                matches!(t.as_str(), "1" | "true" | "yes" | "on")
            }
        }
        None => default,
    }
}

fn parse_optional_int(value: Option<&String>) -> Option<i32> {
    value.and_then(|v| {
        let t = v.trim();
        if t.is_empty() {
            None
        } else {
            t.parse::<i32>().ok()
        }
    })
}

fn parse_int_list(values: &[String]) -> Vec<i64> {
    values
        .iter()
        .filter_map(|v| {
            let t = v.trim();
            if t.is_empty() {
                None
            } else {
                t.parse::<i64>().ok()
            }
        })
        .collect()
}



fn build_query_string(pairs: &[(String, String)]) -> String {
    let mut first = true;
    let mut out = String::new();
    for (k, v) in pairs {
        if !first {
            out.push('&');
        } else {
            first = false;
        }
        out.push_str(&encode(k));
        out.push('=');
        out.push_str(&encode(v));
    }
    out
}

// ---------- Regions Loader ----------

async fn load_regions(state: &AppState) -> (Vec<Region>, HashMap<String, Region>) {
    let payload = api_call(state, "GET", "/v1/regions", None, None).await;
    let mut regions = Vec::new();
    let mut map = HashMap::new();
    if payload.get("code").and_then(|c| c.as_str()) == Some("OKAY") {
        if let Some(arr) = payload.get("data").and_then(|d| d.as_array()) {
            for r in arr {
                if let Some(obj) = r.as_object() {
                    let id = obj
                        .get("id")
                        .and_then(|v| v.as_str())
                        .unwrap_or_default()
                        .to_string();
                    let name = obj
                        .get("name")
                        .and_then(|v| v.as_str())
                        .unwrap_or(&id)
                        .to_string();
                    let slug = obj
                        .get("slug")
                        .and_then(|v| v.as_str())
                        .unwrap_or("")
                        .to_string();
                    let country = obj
                        .get("country")
                        .and_then(|v| v.as_str())
                        .unwrap_or("")
                        .to_string();
                    let city = obj
                        .get("city")
                        .and_then(|v| v.as_str())
                        .unwrap_or("")
                        .to_string();
                    let latitude = obj.get("latitude").and_then(|v| v.as_f64());
                    let longitude = obj.get("longitude").and_then(|v| v.as_f64());

                    let region = Region {
                        id: id.clone(),
                        name,
                        slug,
                        country,
                        city,
                        latitude,
                        longitude,
                    };
                    regions.push(region.clone());
                    map.insert(id, region);
                }
            }
        }
    }
    (regions, map)
}

// ---------- Wizard Step 1 Template ----------

#[derive(Template)]
#[template(path = "step_1.html")]
struct Step1Template<'a> {
    current_user: Option<CurrentUser>,
    api_hostname: String,
    base_url: String,
    flash_messages: Vec<String>,
    has_flash_messages: bool,
    regions: &'a [Region],
    form_data: Step1FormData,
}

async fn create_step_1(
    State(state): State<AppState>,
    jar: CookieJar,
    axum::extract::Query(q): axum::extract::Query<HashMap<String, String>>,
) -> impl IntoResponse {
    if let Some(r) = ensure_admin_or_owner(&state, &jar) {
        return r.into_response();
    }
    let base = parse_wizard_base(&q);
    let (regions, _lookup) = load_regions(&state).await;
    let mut region_sel = base.region.clone();
    if region_sel.is_empty() && !regions.is_empty() {
        region_sel = regions[0].id.clone();
    }
    let TemplateGlobals {
        current_user,
        api_hostname,
        base_url,
        flash_messages,
        has_flash_messages,
    } = build_template_globals(&state, &jar);
    let form_data = Step1FormData {
        region: region_sel,
        instance_class: base.instance_class.clone(),
        plan_type: base.plan_type.clone(),
    };
    inject_context(
        &state,
        &jar,
        Step1Template {
            current_user,
            api_hostname,
            base_url,
            flash_messages,
            has_flash_messages,
            regions: &regions,
            form_data,
        }
        .render()
        .unwrap(),
    )
}

// ---------- Wizard Step 2 (Hostnames & IP Assignment) ----------

#[derive(Template)]
#[template(path = "step_2.html")]
struct Step2Template<'a> {
    current_user: Option<CurrentUser>,
    api_hostname: String,
    base_url: String,
    flash_messages: Vec<String>,
    has_flash_messages: bool,
    base_state: &'a BaseState,
    form_data: Step2FormData,
    back_url: String,
    submit_url: String,
}

async fn create_step_2(
    State(state): State<AppState>,
    jar: CookieJar,
    axum::extract::Query(q): axum::extract::Query<HashMap<String, String>>,
) -> impl IntoResponse {
    if let Some(r) = ensure_admin_or_owner(&state, &jar) {
        return r.into_response();
    }
    let mut base = parse_wizard_base(&q);
    if base.region.is_empty() {
        return Redirect::to("/create/step-1").into_response();
    }
    // If hostnames passed as comma separated in textarea update parsing
    if let Some(raw_hosts) = q.get("hostnames") {
        base.hostnames = raw_hosts
            .split(',')
            .map(|s| s.trim().to_string())
            .filter(|s| !s.is_empty())
            .collect();
    }
    let back_pairs = build_base_query_pairs(&base);
    let back_q = build_query_string(&back_pairs);
    let back_url = if back_q.is_empty() {
        absolute_url(&state, "/create/step-1")
    } else {
        absolute_url(&state, &format!("/create/step-1?{}", back_q))
    };
    let hostnames_text = base.hostnames.join(", ");
    let TemplateGlobals {
        current_user,
        api_hostname,
        base_url,
        flash_messages,
        has_flash_messages,
    } = build_template_globals(&state, &jar);
    let form_data = Step2FormData {
        hostnames_text,
        assign_ipv4: base.assign_ipv4,
        assign_ipv6: base.assign_ipv6,
        floating_ip_count: base.floating_ip_count.to_string(),
    };
    inject_context(
        &state,
        &jar,
        Step2Template {
            current_user,
            api_hostname,
            base_url,
            flash_messages,
            has_flash_messages,
            base_state: &base,
            form_data,
            back_url,
            submit_url: absolute_url(&state, "/create/step-3"),
        }
        .render()
        .unwrap(),
    )
}

// ---------- Wizard Step 3 (Product selection or custom resources) ----------




#[derive(Template)]
#[template(path = "step_3_fixed.html")]
struct Step3FixedTemplate<'a> {
    current_user: Option<CurrentUser>,
    api_hostname: String,
    base_url: String,
    flash_messages: Vec<String>,
    has_flash_messages: bool,
    base_state: &'a BaseState,
    products: &'a [ProductView],
    has_products: bool,
    selected_product_id: String,
    region_name: String,
    floating_ip_count: String,
    back_url: String,
    submit_url: String,
    restart_url: String,
    ssh_key_ids_csv: String,
    hostnames_csv: String,
}


#[derive(Template)]
#[template(path = "step_3_custom.html")]
struct Step3CustomTemplate<'a> {
    current_user: Option<CurrentUser>,
    api_hostname: String,
    base_url: String,
    flash_messages: Vec<String>,
    has_flash_messages: bool,
    base_state: &'a BaseState,
    region_name: String,
    floating_ip_count: String,
    back_url: String,
    submit_url: String,
    requirements: Vec<String>,
    minimum_ram: i32,
    minimum_disk: i32,
    form_values: CustomPlanFormValues,
    ssh_key_ids_csv: String,
    hostnames_csv: String,
}

fn value_to_short_string(value: &Value) -> String {
    match value {
        Value::String(s) => s.to_string(),
        Value::Number(n) => n.to_string(),
        Value::Bool(b) => b.to_string(),
        Value::Array(arr) => arr
            .iter()
            .map(value_to_short_string)
            .collect::<Vec<_>>()
            .join(", "),
        Value::Object(obj) => {
            let mut parts = Vec::new();
            for (key, val) in obj {
                parts.push(format!("{}: {}", key, value_to_short_string(val)));
            }
            parts.join(", ")
        }
        Value::Null => String::new(),
    }
}



async fn load_products(state: &AppState, region_id: &str) -> Vec<ProductView> {
    let params = vec![("regionId".into(), region_id.to_string())];
    let payload = api_call(state, "GET", "/v1/products", None, Some(params)).await;
    let mut out = vec![];
    if payload.get("code").and_then(|c| c.as_str()) == Some("OKAY") {
        if let Some(arr) = payload.get("data").and_then(|d| d.as_array()) {
            for item in arr {
                if let Some(obj) = item.as_object() {
                    let id = obj
                        .get("id")
                        .and_then(|v| v.as_str())
                        .unwrap_or_default()
                        .to_string();

                    let plan = obj.get("plan").and_then(|v| v.as_object());
                    let price_items = obj.get("priceItems").and_then(|v| v.as_array());

                    let name = id.clone();
                    
                    let display_name = name.clone();
                    let description = obj
                        .get("description")
                        .and_then(|v| v.as_str())
                        .unwrap_or("")
                        .to_string();
                    let tags = obj
                        .get("tags")
                        .and_then(|v| v.as_str())
                        .unwrap_or("")
                        .to_string(); 

                    let mut spec_entries = Vec::new();
                    let mut cpu = None;
                    let mut ram = None;
                    let mut storage = None;
                    let mut bandwidth = None;

                    if let Some(p) = plan {
                        if let Some(spec) = p.get("specification").and_then(|v| v.as_object()) {
                            if let Some(c) = spec.get("cpu") {
                                let val = value_to_short_string(c);
                                cpu = Some(format!("{} vCPU", val));
                                spec_entries.push(ProductEntry { term: "CPU".into(), value: format!("{} vCPU", val) });
                            }
                            if let Some(r) = spec.get("ram") {
                                let val = value_to_short_string(r);
                                ram = Some(format!("{} GB", val));
                                spec_entries.push(ProductEntry { term: "RAM".into(), value: format!("{} GB", val) });
                            }
                            if let Some(s) = spec.get("storage") {
                                let val = value_to_short_string(s);
                                storage = Some(format!("{} GB", val));
                                spec_entries.push(ProductEntry { term: "Storage".into(), value: format!("{} GB", val) });
                            }
                            if let Some(b) = spec.get("bandwidthInTB") {
                                let val = value_to_short_string(b);
                                bandwidth = Some(format!("{} TB", val));
                                spec_entries.push(ProductEntry { term: "Bandwidth".into(), value: format!("{} TB", val) });
                            }
                        }
                    }

                    let mut price_entries = Vec::new();
                    if let Some(items) = price_items {
                        for item in items {
                            if let Some(monthly) = item.get("monthlyPrice") {
                                price_entries.push(ProductEntry { term: "Monthly".into(), value: format!("${}", value_to_short_string(monthly)) });
                            }
                        }
                    }

                    out.push(ProductView {
                        id,
                        name,
                        display_name,
                        description,
                        tags,
                        spec_entries,
                        price_entries,
                        cpu,
                        ram,
                        storage,
                        bandwidth,
                    });
                }
            }
        }
    }
    out
}

async fn create_step_3(
    State(state): State<AppState>,
    jar: CookieJar,
    axum::extract::Query(q): axum::extract::Query<HashMap<String, String>>,
) -> impl IntoResponse {
    if let Some(r) = ensure_admin_or_owner(&state, &jar) {
        return r.into_response();
    }
    let base = parse_wizard_base(&q);
    if base.hostnames.is_empty() || base.region.is_empty() {
        return Redirect::to("/create/step-1").into_response();
    }
    let back_pairs = build_base_query_pairs(&base);
    let back_q = build_query_string(&back_pairs);
    let back_url = if back_q.is_empty() {
        absolute_url(&state, "/create/step-2")
    } else {
        absolute_url(&state, &format!("/create/step-2?{}", back_q))
    };
    // Build the hostnames CSV and prepare ssh key CSV for the template where needed
    let hostnames_csv = base.hostnames.join(",");
    let ssh_key_ids_csv = base.ssh_key_ids.iter().map(|id| id.to_string()).collect::<Vec<_>>().join(",");

    if base.plan_type == "fixed" {
        let products = load_products(&state, &base.region).await;
        let selected_product_id = q.get("product_id").cloned().unwrap_or_default();
        let TemplateGlobals {
            current_user,
            api_hostname,
            base_url,
            flash_messages,
            has_flash_messages,
        } = build_template_globals(&state, &jar);
        // Use the outer variables defined above
        return inject_context(
            &state,
            &jar,
            Step3FixedTemplate {
                current_user,
                api_hostname,
                base_url,
                flash_messages,
                has_flash_messages,
                base_state: &base,
                products: &products,
                has_products: !products.is_empty(),
                selected_product_id,
                region_name: base.region.clone(),
                floating_ip_count: base.floating_ip_count.to_string(),
                back_url,
                submit_url: absolute_url(&state, "/create/step-4"),
                restart_url: absolute_url(&state, "/create/step-1"),
                ssh_key_ids_csv: ssh_key_ids_csv.clone(),
                hostnames_csv: hostnames_csv.clone(),
            }
            .render()
            .unwrap(),
        );
    }
    let cpu = q.get("cpu").cloned().unwrap_or_else(|| "2".into());
    let ram = q.get("ramInGB").cloned().unwrap_or_else(|| "4".into());
    let disk = q.get("diskInGB").cloned().unwrap_or_else(|| "50".into());
    let bw = q
        .get("bandwidthInTB")
        .cloned()
        .unwrap_or_else(|| "1".into());
    
    let hostnames_csv = base.hostnames.join(",");
    let TemplateGlobals {
        current_user,
        api_hostname,
        base_url,
        flash_messages,
        has_flash_messages,
    } = build_template_globals(&state, &jar);
    let form_values = CustomPlanFormValues {
        cpu,
        ram_in_gb: ram,
        disk_in_gb: disk,
        bandwidth_in_tb: bw,
    };
    inject_context(
        &state,
        &jar,
        Step3CustomTemplate {
            current_user,
            api_hostname,
            base_url,
            flash_messages,
            has_flash_messages,
            base_state: &base,
            region_name: base.region.clone(),
            floating_ip_count: base.floating_ip_count.to_string(),
            back_url,
            submit_url: absolute_url(&state, "/create/step-5"),
            requirements: Vec::new(),
            minimum_ram: 1,
            minimum_disk: 1,
            form_values,
            ssh_key_ids_csv: ssh_key_ids_csv.clone(),
            hostnames_csv: hostnames_csv,
        }
        .render()
        .unwrap(),
    )
}

// ---------- Wizard Step 4 (Extras for fixed plans) ----------
#[derive(Clone)]
struct ExtrasFormValues {
    extra_disk: String,
    extra_bandwidth: String,
}

#[derive(Template)]
#[template(path = "step_4.html")]
struct Step4Template<'a> {
    current_user: Option<CurrentUser>,
    api_hostname: String,
    base_url: String,
    flash_messages: Vec<String>,
    has_flash_messages: bool,
    base_state: &'a BaseState,
    floating_ip_count: String,
    product_id: String,
    ssh_key_ids_csv: String,
    hostnames_csv: String,
    extras: ExtrasFormValues,
    back_url: String,
    submit_url: String,
}

async fn create_step_4(
    State(state): State<AppState>,
    jar: CookieJar,
    axum::extract::Query(q): axum::extract::Query<HashMap<String, String>>,
) -> impl IntoResponse {
    if let Some(r) = ensure_admin_or_owner(&state, &jar) {
        return r.into_response();
    }
    let base = parse_wizard_base(&q);
    if base.hostnames.is_empty() || base.region.is_empty() {
        return Redirect::to("/create/step-1").into_response();
    }
    let ssh_key_ids_csv = base.ssh_key_ids.iter().map(|id| id.to_string()).collect::<Vec<_>>().join(",");
    let hostnames_csv = base.hostnames.join(",");
    let back_pairs = build_base_query_pairs(&base);
    let back_q = build_query_string(&back_pairs);
    let back_url = if back_q.is_empty() {
        absolute_url(&state, "/create/step-3")
    } else {
        absolute_url(&state, &format!("/create/step-3?{}", back_q))
    };
    if base.plan_type != "fixed" {
        let next_pairs = build_base_query_pairs(&base);
        let next_q = build_query_string(&next_pairs);
        let next_url = if next_q.is_empty() {
            "/create/step-5".to_string()
        } else {
            format!("/create/step-5?{}", next_q)
        };
        return Redirect::to(&next_url).into_response();
    }
    let product_id = q.get("product_id").cloned().unwrap_or_default();
    if product_id.is_empty() {
        return Redirect::to("/create/step-3").into_response();
    }
    let TemplateGlobals {
        current_user,
        api_hostname,
        base_url,
        flash_messages,
        has_flash_messages,
    } = build_template_globals(&state, &jar);
    let extras = ExtrasFormValues {
        extra_disk: q.get("extra_disk").cloned().unwrap_or_else(|| "0".into()),
        extra_bandwidth: q
            .get("extra_bandwidth")
            .cloned()
            .unwrap_or_else(|| "0".into()),
    };
    inject_context(
        &state,
        &jar,
        Step4Template {
            current_user,
            api_hostname,
            base_url,
            flash_messages,
            has_flash_messages,
            base_state: &base,
            floating_ip_count: base.floating_ip_count.to_string(),
            product_id,
            ssh_key_ids_csv: ssh_key_ids_csv,
            hostnames_csv: hostnames_csv,
            extras,
            back_url,
            submit_url: absolute_url(&state, "/create/step-5"),
        }
        .render()
        .unwrap(),
    )
}

// ---------- Wizard Step 5 (OS selection) ----------

#[derive(Clone, Default)]
struct CustomPlanCarry {
    cpu: String,
    ram_in_gb: String,
    disk_in_gb: String,
    bandwidth_in_tb: String,
}

#[derive(Template)]
#[template(path = "step_5.html")]
struct Step5Template<'a> {
    current_user: Option<CurrentUser>,
    api_hostname: String,
    base_url: String,
    flash_messages: Vec<String>,
    has_flash_messages: bool,
    base_state: &'a BaseState,
    os_list: &'a [OsItem],
    selected_os_id: String,
    product_id: String,
    extra_disk: String,
    extra_bandwidth: String,
    custom_plan: CustomPlanCarry,
    floating_ip_count: String,
    back_url: String,
    submit_url: String,
    hostnames_csv: String,
    ssh_key_ids_csv: String,
}

async fn load_os_list(state: &AppState) -> Vec<OsItem> {
    let payload = api_call(state, "GET", "/v1/os", None, None).await;
    let mut out = vec![];
    if payload.get("code").and_then(|c| c.as_str()) == Some("OKAY") {
        if let Some(arr) = payload
            .get("data")
            .and_then(|d| d.get("os"))
            .and_then(|o| o.as_array())
        {
            for item in arr {
                if let Some(obj) = item.as_object() {
                    let id = obj
                        .get("id")
                        .and_then(|v| v.as_str())
                        .unwrap_or("")
                        .to_string();
                    let name = obj
                        .get("name")
                        .and_then(|v| v.as_str())
                        .unwrap_or("")
                        .to_string();
                    let family = obj
                        .get("family")
                        .and_then(|v| v.as_str())
                        .unwrap_or("")
                        .to_string();
                    let arch = obj
                        .get("arch")
                        .and_then(|v| v.as_str())
                        .map(|s| s.to_string());
                    let min_ram = obj
                        .get("minRam")
                        .map(value_to_short_string)
                        .filter(|s| !s.is_empty());
                    let is_default = obj
                        .get("isDefault")
                        .and_then(|v| v.as_bool())
                        .unwrap_or(false);
                    out.push(OsItem {
                        id,
                        name,
                        family,
                        arch,
                        min_ram,
                        is_default,
                    });
                }
            }
        }
    }
    out
}


async fn load_applications(state: &AppState) -> Vec<ApplicationView> {
    let payload = api_call(state, "GET", "/v1/applications", None, None).await;
    let mut apps = Vec::new();
    if payload.get("code").and_then(|c| c.as_str()) == Some("OKAY") {
        if let Some(arr) = payload
            .get("data")
            .and_then(|d| d.get("applications")) // Note: API spec says data is array of ApplicationSchema, but code expects data.applications. Checking spec again...
            // Spec says: "data": {"type": "array", "items": {"$ref": "#/components/schemas/ApplicationSchema"}}
            // So it should be payload.get("data").and_then(|d| d.as_array())
            // But let's stick to what was working or try both.
            .or_else(|| payload.get("data"))
            .and_then(|a| a.as_array())
        {
            for item in arr {
                if let Some(obj) = item.as_object() {
                    let id = obj
                        .get("id")
                        .and_then(|v| v.as_i64())
                        .map(|n| n.to_string())
                        .or_else(|| {
                            obj.get("id")
                                .and_then(|v| v.as_str())
                                .map(|s| s.to_string())
                        })
                        .unwrap_or_default();
                    let name = obj
                        .get("name")
                        .and_then(|v| v.as_str())
                        .unwrap_or(&id)
                        .to_string();
                    let description = obj
                        .get("description")
                        .and_then(|v| v.as_str())
                        .unwrap_or("")
                        .to_string();
                    let price = obj
                        .get("price")
                        .map(value_to_short_string)
                        .or_else(|| obj.get("pricing").map(value_to_short_string))
                        .filter(|s| !s.is_empty());
                    let tags = obj.get("tag").and_then(|v| v.as_str()).map(|s| s.to_string());
                    
                    apps.push(ApplicationView {
                        id,
                        name,
                        description,
                        price,
                        tags,
                    });
                }
            }
        }
    }
    apps
}

async fn create_step_5(
    State(state): State<AppState>,
    jar: CookieJar,
    axum::extract::Query(q): axum::extract::Query<HashMap<String, String>>,
) -> impl IntoResponse {
    if let Some(r) = ensure_admin_or_owner(&state, &jar) {
        return r.into_response();
    }
    let base = parse_wizard_base(&q);
    if base.hostnames.is_empty() || base.region.is_empty() {
        return Redirect::to("/create/step-1").into_response();
    }
    let TemplateGlobals {
        current_user,
        api_hostname,
        base_url,
        flash_messages,
        has_flash_messages,
    } = build_template_globals(&state, &jar);
    let product_id = q.get("product_id").cloned().unwrap_or_default();
    if base.plan_type == "fixed" && product_id.is_empty() {
        return Redirect::to("/create/step-3").into_response();
    }
    let extra_disk = q.get("extra_disk").cloned().unwrap_or_else(|| "0".into());
    let extra_bandwidth = q
        .get("extra_bandwidth")
        .cloned()
        .unwrap_or_else(|| "0".into());
    let custom_plan = CustomPlanCarry {
        cpu: q.get("cpu").cloned().unwrap_or_else(|| "2".into()),
        ram_in_gb: q.get("ramInGB").cloned().unwrap_or_else(|| "4".into()),
        disk_in_gb: q.get("diskInGB").cloned().unwrap_or_else(|| "50".into()),
        bandwidth_in_tb: q
            .get("bandwidthInTB")
            .cloned()
            .unwrap_or_else(|| "1".into()),
    };
    let os_list = load_os_list(&state).await;
    let mut selected_os_id = base.os_id.clone();
    if selected_os_id.is_empty() {
        selected_os_id = q.get("os_id").cloned().unwrap_or_default();
    }
    if selected_os_id.is_empty() {
        selected_os_id = os_list
            .iter()
            .find(|o| o.is_default)
            .map(|o| o.id.clone())
            .or_else(|| os_list.first().map(|o| o.id.clone()))
            .unwrap_or_default();
    }
    let mut back_pairs = build_base_query_pairs(&base);
    let back_target = if base.plan_type == "fixed" {
        if !product_id.is_empty() {
            back_pairs.push(("product_id".into(), product_id.clone()));
        }
        back_pairs.push(("extra_disk".into(), extra_disk.clone()));
        back_pairs.push(("extra_bandwidth".into(), extra_bandwidth.clone()));
        "/create/step-4"
    } else {
        back_pairs.push(("cpu".into(), custom_plan.cpu.clone()));
        back_pairs.push(("ramInGB".into(), custom_plan.ram_in_gb.clone()));
        back_pairs.push(("diskInGB".into(), custom_plan.disk_in_gb.clone()));
        back_pairs.push(("bandwidthInTB".into(), custom_plan.bandwidth_in_tb.clone()));
        "/create/step-3"
    };
    let back_q = build_query_string(&back_pairs);
    let back_url = if back_q.is_empty() {
        absolute_url(&state, back_target)
    } else {
        absolute_url(&state, &format!("{}?{}", back_target, back_q))
    };
    let hostnames_csv = base.hostnames.join(",");
    let ssh_key_ids_csv = base.ssh_key_ids.iter().map(|id| id.to_string()).collect::<Vec<_>>().join(",");
    inject_context(
        &state,
        &jar,
        Step5Template {
            current_user,
            api_hostname,
            base_url,
            flash_messages,
            has_flash_messages,
            base_state: &base,
            os_list: &os_list,
            selected_os_id,
            product_id,
            extra_disk,
            extra_bandwidth,
            custom_plan,
            floating_ip_count: base.floating_ip_count.to_string(),
            back_url,
            submit_url: absolute_url(&state, "/create/step-6"),
            hostnames_csv: hostnames_csv,
            ssh_key_ids_csv: ssh_key_ids_csv,
        }
        .render()
        .unwrap(),
    )
}

// ---------- Wizard Step 6 (SSH key selection) ----------
struct SelectableSshKey {
    id: String,
    name: String,
    selected: bool,
}

#[derive(Template)]
#[template(path = "step_6.html")]
struct Step6Template<'a> {
    current_user: Option<CurrentUser>,
    api_hostname: String,
    base_url: String,
    flash_messages: Vec<String>,
    has_flash_messages: bool,
    base_state: &'a BaseState,
    floating_ip_count: String,
    ssh_keys: Vec<SelectableSshKey>,
    product_id: String,
    extra_disk: String,
    extra_bandwidth: String,
    custom_plan: CustomPlanCarry,
    back_url: String,
    submit_url: String,
    manage_keys_url: String,
    hostnames_csv: String,
}

async fn create_step_6(
    State(state): State<AppState>,
    jar: CookieJar,
    axum::extract::Query(q): axum::extract::Query<HashMap<String, String>>,
) -> impl IntoResponse {
    if let Some(r) = ensure_admin_or_owner(&state, &jar) {
        return r.into_response();
    }
    let base = parse_wizard_base(&q);
    if base.hostnames.is_empty() || base.region.is_empty() {
        return Redirect::to("/create/step-1").into_response();
    }
    if base.os_id.is_empty() {
        return Redirect::to("/create/step-5").into_response();
    }
    let TemplateGlobals {
        current_user,
        api_hostname,
        base_url,
        flash_messages,
        has_flash_messages,
    } = build_template_globals(&state, &jar);
    let product_id = q.get("product_id").cloned().unwrap_or_default();
    if base.plan_type == "fixed" && product_id.is_empty() {
        return Redirect::to("/create/step-3").into_response();
    }
    let extra_disk = q.get("extra_disk").cloned().unwrap_or_else(|| "0".into());
    let extra_bandwidth = q
        .get("extra_bandwidth")
        .cloned()
        .unwrap_or_else(|| "0".into());
    let custom_plan = CustomPlanCarry {
        cpu: q.get("cpu").cloned().unwrap_or_else(|| "2".into()),
        ram_in_gb: q.get("ramInGB").cloned().unwrap_or_else(|| "4".into()),
        disk_in_gb: q.get("diskInGB").cloned().unwrap_or_else(|| "50".into()),
        bandwidth_in_tb: q
            .get("bandwidthInTB")
            .cloned()
            .unwrap_or_else(|| "1".into()),
    };
    let mut back_pairs = build_base_query_pairs(&base);
    let back_target = if base.plan_type == "fixed" {
        if !product_id.is_empty() {
            back_pairs.push(("product_id".into(), product_id.clone()));
        }
        back_pairs.push(("extra_disk".into(), extra_disk.clone()));
        back_pairs.push(("extra_bandwidth".into(), extra_bandwidth.clone()));
        "/create/step-5"
    } else {
        back_pairs.push(("cpu".into(), custom_plan.cpu.clone()));
        back_pairs.push(("ramInGB".into(), custom_plan.ram_in_gb.clone()));
        back_pairs.push(("diskInGB".into(), custom_plan.disk_in_gb.clone()));
        back_pairs.push(("bandwidthInTB".into(), custom_plan.bandwidth_in_tb.clone()));
        "/create/step-5"
    };
    let back_q = build_query_string(&back_pairs);
    let back_url = if back_q.is_empty() {
        absolute_url(&state, back_target)
    } else {
        absolute_url(&state, &format!("{}?{}", back_target, back_q))
    };
    let customer_id = fetch_default_customer_id(&state).await;
    let ssh_keys = load_ssh_keys_api(&state, customer_id).await;
    let selected_ids: HashSet<String> =
        base.ssh_key_ids.iter().map(|id| id.to_string()).collect();
    let selectable: Vec<SelectableSshKey> = ssh_keys
        .into_iter()
        .map(|key| {
            let is_selected = selected_ids.contains(&key.id);
            SelectableSshKey {
                id: key.id,
                name: key.name,
                selected: is_selected,
            }
        })
        .collect();
    let hostnames_csv = base.hostnames.join(",");
    let _ssh_key_ids_csv = base.ssh_key_ids.iter().map(|id| id.to_string()).collect::<Vec<_>>().join(",");
    inject_context(
        &state,
        &jar,
        Step6Template {
            current_user,
            api_hostname,
            base_url,
            flash_messages,
            has_flash_messages,
            base_state: &base,
            floating_ip_count: base.floating_ip_count.to_string(),
            ssh_keys: selectable,
            product_id,
            extra_disk,
            extra_bandwidth,
            custom_plan,
            back_url,
            submit_url: absolute_url(&state, "/create/step-7"),
            manage_keys_url: absolute_url(&state, "/ssh-keys"),
            hostnames_csv,
        }
        .render()
        .unwrap(),
    )
}

// ---------- Wizard Step 7 (Review & Create) ----------
#[derive(Clone, Default)]
struct PlanReviewState {
    product_id: String,
    extra_disk: String,
    extra_bandwidth: String,
    cpu: String,
    ram_in_gb: String,
    disk_in_gb: String,
    bandwidth_in_tb: String,
}

#[derive(Template)]
#[template(path = "step_7.html")]
struct Step7Template<'a> {
    current_user: Option<CurrentUser>,
    api_hostname: String,
    base_url: String,
    flash_messages: Vec<String>,
    has_flash_messages: bool,
    base_state: &'a BaseState,
    floating_ip_count: String,
    plan_state: PlanReviewState,
    plan_type_label: String,
    region_name: String,
    hostnames_display: String,
    plan_summary: Vec<ProductEntry>,
    has_plan_summary: bool,
    price_entries: Vec<ProductEntry>,
    has_price_entries: bool,
    selected_os_label: String,
    ssh_keys_display: String,
    footnote_text: String,
    has_footnote: bool,
    back_url: String,
    submit_url: String,
    ssh_key_ids_csv: String,
    hostnames_csv: String,
}

#[derive(Template)]
#[template(path = "step_8.html")]
struct Step8Template {
    current_user: Option<CurrentUser>,
    api_hostname: String,
    base_url: String,
    flash_messages: Vec<String>,
    has_flash_messages: bool,
    back_url: String,
    status_label: String,
    code: Option<String>,
    detail: Option<String>,
    errors: Vec<String>,
}

async fn create_step_7_core(
    state: AppState,
    jar: CookieJar,
    method: axum::http::Method,
    query: HashMap<String, String>,
    form: HashMap<String, String>,
) -> impl IntoResponse {
    if let Some(r) = ensure_admin_or_owner(&state, &jar) {
        return r.into_response();
    }
    let source = if method == axum::http::Method::POST {
        &form
    } else {
        &query
    };
    let base = parse_wizard_base(source);
    if base.hostnames.is_empty() || base.region.is_empty() {
        return Redirect::to("/create/step-1").into_response();
    }
    if base.os_id.is_empty() {
        return Redirect::to("/create/step-5").into_response();
    }
    let mut plan_state = PlanReviewState::default();
    if base.plan_type == "fixed" {
        plan_state.product_id = source.get("product_id").cloned().unwrap_or_default();
        if plan_state.product_id.is_empty() {
            return Redirect::to("/create/step-3").into_response();
        }
        plan_state.extra_disk = source
            .get("extra_disk")
            .cloned()
            .unwrap_or_else(|| "0".into());
        plan_state.extra_bandwidth = source
            .get("extra_bandwidth")
            .cloned()
            .unwrap_or_else(|| "0".into());
    } else {
        plan_state.cpu = source.get("cpu").cloned().unwrap_or_else(|| "2".into());
        plan_state.ram_in_gb = source.get("ramInGB").cloned().unwrap_or_else(|| "4".into());
        plan_state.disk_in_gb = source
            .get("diskInGB")
            .cloned()
            .unwrap_or_else(|| "50".into());
        plan_state.bandwidth_in_tb = source
            .get("bandwidthInTB")
            .cloned()
            .unwrap_or_else(|| "1".into());
    }
    if method == axum::http::Method::POST {
        let mut payload = serde_json::json!({
            "hostnames": base.hostnames,
            "region": base.region,
            "class": base.instance_class,
            "assignIpv4": base.assign_ipv4,
            "assignIpv6": base.assign_ipv6,
            "osId": base.os_id,
        });
        if base.floating_ip_count > 0 {
            payload["floatingIPCount"] = Value::from(base.floating_ip_count);
        }
        if !base.ssh_key_ids.is_empty() {
            payload["sshKeyIds"] = Value::from(base.ssh_key_ids.clone());
        }
        if base.plan_type == "fixed" {
            payload["productId"] = Value::from(plan_state.product_id.clone());
            let mut extras = serde_json::Map::new();
            if let Some(d) = plan_state
                .extra_disk
                .trim()
                .parse::<i64>()
                .ok()
                .filter(|v| *v > 0)
            {
                extras.insert("diskInGB".into(), Value::from(d));
            }
            if let Some(b) = plan_state
                .extra_bandwidth
                .trim()
                .parse::<i64>()
                .ok()
                .filter(|v| *v > 0)
            {
                extras.insert("bandwidthInTB".into(), Value::from(b));
            }
            if !extras.is_empty() {
                payload["extraResource"] = Value::Object(extras);
            }
        } else {
            let mut extras = serde_json::Map::new();
            if let Some(cpu) = plan_state.cpu.trim().parse::<i64>().ok() {
                extras.insert("cpu".into(), Value::from(cpu));
            }
            if let Some(ram) = plan_state.ram_in_gb.trim().parse::<i64>().ok() {
                extras.insert("ramInGB".into(), Value::from(ram));
            }
            if let Some(disk) = plan_state.disk_in_gb.trim().parse::<i64>().ok() {
                extras.insert("diskInGB".into(), Value::from(disk));
            }
            if let Some(bw) = plan_state.bandwidth_in_tb.trim().parse::<i64>().ok() {
                extras.insert("bandwidthInTB".into(), Value::from(bw));
            }
            if !extras.is_empty() {
                payload["extraResource"] = Value::Object(extras);
            }
        }
        let resp = api_call(&state, "POST", "/v1/instances", Some(payload), None).await;
        if resp.get("code").and_then(|c| c.as_str()) == Some("OKAY")
            || resp.get("code").and_then(|c| c.as_str()) == Some("CREATED")
        {
            return Redirect::to("/instances").into_response();
        } else {
            // Build error / result page
            let mut errors: Vec<String> = Vec::new();
            if let Some(detail) = resp.get("detail").and_then(|d| d.as_str()) {
                if !detail.trim().is_empty() {
                    errors.push(detail.to_string());
                }
            }
            // Some APIs return 'errors' as array or map
            if let Some(arr) = resp.get("errors").and_then(|e| e.as_array()) {
                for entry in arr {
                    if let Some(s) = entry.as_str() {
                        errors.push(s.to_string());
                    } else if let Some(obj) = entry.as_object() {
                        for (k, v) in obj {
                            if let Some(s) = v.as_str() {
                                errors.push(format!("{}: {}", k, s));
                            } else {
                                errors.push(format!("{}: {}", k, value_to_short_string(v)));
                            }
                        }
                    } else {
                        errors.push(value_to_short_string(entry));
                    }
                }
            } else if let Some(obj) = resp.get("errors").and_then(|e| e.as_object()) {
                for (k, v) in obj {
                    if let Some(s) = v.as_str() {
                        errors.push(format!("{}: {}", k, s));
                    } else {
                        errors.push(format!("{}: {}", k, value_to_short_string(v)));
                    }
                }
            }
            let code = resp.get("code").and_then(|c| c.as_str()).map(|s| s.to_string());
            let detail = resp.get("detail").and_then(|d| d.as_str()).map(|s| s.to_string());
            // Do not expose raw JSON to rendered templates - keep UI friendly.
            let TemplateGlobals { current_user, api_hostname, base_url, flash_messages, has_flash_messages } = build_template_globals(&state, &jar);
                return inject_context(
                &state,
                &jar,
                Step8Template {
                    current_user,
                    api_hostname,
                    base_url,
                    flash_messages,
                    has_flash_messages,
                    back_url: absolute_url(&state, "/create/step-6"),
                    status_label: "Failed".into(),
                    code,
                    detail,
                    errors,
                }
                .render()
                .unwrap(),
            );
        }
    }
    let TemplateGlobals {
        current_user,
        api_hostname,
        base_url,
        flash_messages,
        has_flash_messages,
    } = build_template_globals(&state, &jar);
    let mut plan_summary = Vec::new();
    let mut price_entries = Vec::new();
    let mut footnote = None;
    
    if base.plan_type == "fixed" {
        let products = load_products(&state, &base.region).await;
        if let Some(prod) = products.into_iter().find(|p| p.id == plan_state.product_id) {
            plan_summary = prod.spec_entries.clone();
            price_entries = prod.price_entries.clone();
            let desc = prod.description.clone();
            if !desc.trim().is_empty() {
                footnote = Some(desc.clone());
            }
        }
    } else {
        let mut summary = Vec::new();
        if !plan_state.cpu.trim().is_empty() {
            summary.push(ProductEntry {
                term: "vCPU".into(),
                value: plan_state.cpu.clone(),
            });
        }
        if !plan_state.ram_in_gb.trim().is_empty() {
            summary.push(ProductEntry {
                term: "RAM (GB)".into(),
                value: plan_state.ram_in_gb.clone(),
            });
        }
        if !plan_state.disk_in_gb.trim().is_empty() {
            summary.push(ProductEntry {
                term: "Disk (GB)".into(),
                value: plan_state.disk_in_gb.clone(),
            });
        }
        if !plan_state.bandwidth_in_tb.trim().is_empty() {
            summary.push(ProductEntry {
                term: "Bandwidth (TB)".into(),
                value: plan_state.bandwidth_in_tb.clone(),
            });
        }
        plan_summary = summary;
    }
    let os_list = load_os_list(&state).await;
    let selected_os_label = os_list
        .iter()
        .find(|os| os.id == base.os_id)
        .map(|os| os.name.clone())
        .unwrap_or_else(|| base.os_id.clone());
    let selected_key_ids: Vec<String> = base.ssh_key_ids.iter().map(|id| id.to_string()).collect();
    let ssh_keys_display = if selected_key_ids.is_empty() {
        "None".into()
    } else {
        let id_set: HashSet<_> = selected_key_ids.iter().cloned().collect();
        let customer_id = fetch_default_customer_id(&state).await;
        let ssh_keys = load_ssh_keys_api(&state, customer_id).await;
        let mut names = Vec::new();
        for key in ssh_keys {
            if id_set.contains(&key.id) {
                names.push(key.name);
            }
        }
        if names.is_empty() {
            format!("{} SSH key(s)", id_set.len())
        } else {
            names.join(", ")
        }
    };
    let hostnames_display = if base.hostnames.is_empty() {
        "(none)".into()
    } else {
        base.hostnames.join(", ")
    };
    let hostnames_csv = base.hostnames.join(",");
    let ssh_key_ids_csv = if selected_key_ids.is_empty() {
        "".into()
    } else {
        selected_key_ids.join(",")
    };
    let plan_type_label = if base.plan_type == "fixed" {
        "Fixed plan".into()
    } else {
        "Custom plan".into()
    };
    let mut back_pairs = build_base_query_pairs(&base);
    if base.plan_type == "fixed" {
        back_pairs.push(("product_id".into(), plan_state.product_id.clone()));
        back_pairs.push(("extra_disk".into(), plan_state.extra_disk.clone()));
        back_pairs.push(("extra_bandwidth".into(), plan_state.extra_bandwidth.clone()));
    } else {
        back_pairs.push(("cpu".into(), plan_state.cpu.clone()));
        back_pairs.push(("ramInGB".into(), plan_state.ram_in_gb.clone()));
        back_pairs.push(("diskInGB".into(), plan_state.disk_in_gb.clone()));
        back_pairs.push(("bandwidthInTB".into(), plan_state.bandwidth_in_tb.clone()));
    }
    let back_q = build_query_string(&back_pairs);
    let back_url = if back_q.is_empty() {
        absolute_url(&state, "/create/step-6")
    } else {
        absolute_url(&state, &format!("/create/step-6?{}", back_q))
    };
    let has_plan_summary = !plan_summary.is_empty();
    let has_price_entries = !price_entries.is_empty();
    let footnote_text = footnote.unwrap_or_default();
    let has_footnote = !footnote_text.is_empty();
    inject_context(
        &state,
        &jar,
        Step7Template {
            current_user,
            api_hostname,
            base_url,
            flash_messages,
            has_flash_messages,
            base_state: &base,
            floating_ip_count: base.floating_ip_count.to_string(),
            plan_state,
            plan_type_label,
            region_name: base.region.clone(),
            hostnames_display,
            plan_summary,
            has_plan_summary,
            price_entries,
            has_price_entries,
            selected_os_label,
            ssh_keys_display,
            ssh_key_ids_csv,
            hostnames_csv,
            footnote_text,
            has_footnote,
            back_url,
            submit_url: absolute_url(&state, "/create/step-7"),
        }
        .render()
        .unwrap(),
    )
}

async fn create_step_7_get(
    State(state): State<AppState>,
    jar: CookieJar,
    axum::extract::Query(q): axum::extract::Query<HashMap<String, OneOrMany>>,
) -> impl IntoResponse {
    // For GET requests, query params may have single or multiple values; flatten to CSV strings.
    let mut q_flat: HashMap<String, String> = HashMap::new();
    for (k, v) in q {
        q_flat.insert(k, v.to_csv());
    }
    create_step_7_core(state, jar, axum::http::Method::GET, q_flat, HashMap::new()).await
}

async fn create_step_8(
    State(state): State<AppState>,
    jar: CookieJar,
    axum::extract::Query(q): axum::extract::Query<HashMap<String, String>>,
) -> impl IntoResponse {
    let TemplateGlobals { current_user, api_hostname, base_url, flash_messages, has_flash_messages } = build_template_globals(&state, &jar);
    let code = q.get("code").cloned();
    let detail = q.get("detail").cloned();
    // Raw JSON is no longer rendered in the UI; any raw response can be logged by server
    let errors = q.get("errors").map(|s| s.split('|').map(|s| s.to_string()).collect()).unwrap_or_else(Vec::new);
    inject_context(&state, &jar, Step8Template {
        current_user,
        api_hostname,
        base_url,
        flash_messages,
        has_flash_messages,
        back_url: q.get("back_url").cloned().unwrap_or_else(|| absolute_url(&state, "/create/step-1")),
        status_label: q.get("status_label").cloned().unwrap_or_else(|| "Result".into()),
        code,
        detail,
        errors,
        
    }.render().unwrap())
}

async fn create_step_7_post(
    State(state): State<AppState>,
    jar: CookieJar,
    axum::extract::Query(q): axum::extract::Query<HashMap<String, OneOrMany>>,
    body: axum::body::Bytes,
) -> impl IntoResponse {
    let mut q_flat: HashMap<String, String> = HashMap::new();
    for (k, v) in q {
        q_flat.insert(k, v.to_csv());
    }
    // Try to parse as HashMap<String, Vec<String>> first
    let mut f_flat: HashMap<String, String> = HashMap::new();
    let parsed_map = parse_urlencoded_body(&body);
    for (k, v) in parsed_map {
        f_flat.insert(k, v.join(","));
    }
    create_step_7_core(state, jar, axum::http::Method::POST, q_flat, f_flat).await
}

async fn api_call_wrapper(
    state: &AppState,
    method: &str,
    endpoint: &str,
    data: Option<Value>,
    params: Option<Vec<(String, String)>>,
) -> Value {
    let should_log = !LOGGING_IGNORE_ENDPOINTS.contains(&endpoint);
    if should_log {
        tracing::info!(method, endpoint, ?data, ?params, "API Request");
    }
    let result = api_call(&state.client, &state.api_base_url, &state.api_token, method, endpoint, data, params).await;
    if should_log {
        tracing::info!(response=?result, "API Response");
    }
    result
}

async fn load_regions_wrapper(state: &AppState) -> (Vec<Region>, HashMap<String, Region>) {
    load_regions(&state.client, &state.api_base_url, &state.api_token).await
}

async fn load_products_wrapper(state: &AppState, region_id: &str) -> Vec<ProductView> {
    load_products(&state.client, &state.api_base_url, &state.api_token, region_id).await
}

async fn load_os_list_wrapper(state: &AppState) -> Vec<OsItem> {
    load_os_list(&state.client, &state.api_base_url, &state.api_token).await
}

async fn load_applications_wrapper(state: &AppState) -> Vec<ApplicationView> {
    load_applications(&state.client, &state.api_base_url, &state.api_token).await
}

async fn load_instances_for_user_wrapper(state: &AppState, username: &str) -> Vec<InstanceView> {
    let users_map = state.users.lock().unwrap().clone();
    load_instances_for_user(&state.client, &state.api_base_url, &state.api_token, &users_map, username).await
}
#[derive(Template)]
#[template(path = "users.html")]
struct UsersTemplate {
    current_user: Option<CurrentUser>,
    api_hostname: String,
    base_url: String,
    flash_messages: Vec<String>,
    has_flash_messages: bool,
    rows: Vec<UserTableRow>,
}

struct UserTableRow {
    username: String,
    role: String,
    assigned: String,
}

#[derive(Deserialize)]
struct CreateUserForm {
    username: String,
    password: String,
    role: String,
}

fn ensure_owner(state: &AppState, jar: &CookieJar) -> Option<Redirect> {
    // Redirect to login if not authenticated
    if let Some(r) = ensure_logged_in(state, jar) {
        return Some(r);
    }
    let uname = current_username_from_jar(state, jar)?;
    let users = state.users.lock().unwrap();
    let rec = users.get(&uname)?;
    if rec.role != "owner" {
        return Some(Redirect::to("/instances"));
    }
    None
}

// Ensure the request has an authenticated session, otherwise redirect to login
fn ensure_logged_in(state: &AppState, jar: &CookieJar) -> Option<Redirect> {
    if current_username_from_jar(state, jar).is_none() {
        return Some(Redirect::to("/login"));
    }
    None
}

// Ensure the user is owner or admin (for tasks like creating instances)
fn ensure_admin_or_owner(state: &AppState, jar: &CookieJar) -> Option<Redirect> {
    if let Some(r) = ensure_logged_in(state, jar) {
        return Some(r);
    }
    let uname = current_username_from_jar(state, jar)?;
    let users = state.users.lock().unwrap();
    let rec = users.get(&uname)?;
    if rec.role == "owner" || rec.role == "admin" {
        None
    } else {
        Some(Redirect::to("/instances"))
    }
}

async fn users_list(State(state): State<AppState>, jar: CookieJar) -> impl IntoResponse {
    if let Some(r) = ensure_owner(&state, &jar) {
        return r.into_response();
    }
    let users = state.users.lock().unwrap();
    let mut rows: Vec<UserTableRow> = users
        .iter()
        .map(|(k, v)| {
            let assigned = if v.assigned_instances.is_empty() {
                String::new()
            } else {
                v.assigned_instances.join(", ")
            };
            UserTableRow {
                username: k.clone(),
                role: v.role.clone(),
                assigned,
            }
        })
        .collect();
    rows.sort_by(|a, b| a.username.cmp(&b.username));
    drop(users);
    let TemplateGlobals {
        current_user,
        api_hostname,
        base_url,
        flash_messages,
        has_flash_messages,
    } = build_template_globals(&state, &jar);
    inject_context(
        &state,
        &jar,
        UsersTemplate {
            current_user,
            api_hostname,
            base_url,
            flash_messages,
            has_flash_messages,
            rows,
        }
        .render()
        .unwrap(),
    )
}

async fn users_create(
    State(state): State<AppState>,
    jar: CookieJar,
    Form(form): Form<CreateUserForm>,
) -> impl IntoResponse {
    if let Some(r) = ensure_owner(&state, &jar) {
        return r.into_response();
    }
    let uname = form.username.trim().to_lowercase();
    if uname.is_empty() || form.password.is_empty() {
        return plain_html("Missing username/password");
    }
    if form.role != "owner" && form.role != "admin" {
        return plain_html("Invalid role");
    }
    {
        let mut users = state.users.lock().unwrap();
        if users.contains_key(&uname) {
            return plain_html("Username exists");
        }
        let hash = generate_password_hash(&form.password);
        users.insert(
            uname.clone(),
            UserRecord {
                password: hash,
                role: form.role.clone(),
                assigned_instances: vec![],
            },
        );
        // persist
        let mut serialized: serde_json::Map<String, Value> = serde_json::Map::new();
        for (u, rec) in users.iter() {
            serialized.insert(u.clone(), serde_json::json!({"password": rec.password, "role": rec.role, "assigned_instances": rec.assigned_instances }));
        }
        let _ = std::fs::write(
            "users.json",
            serde_json::to_string_pretty(&Value::Object(serialized)).unwrap(),
        );
    }
    Redirect::to("/users").into_response()
}

#[derive(Deserialize)]
struct ResetPasswordForm {
    new_password: String,
}
async fn reset_password(
    State(state): State<AppState>,
    jar: CookieJar,
    axum::extract::Path(username): axum::extract::Path<String>,
    Form(form): Form<ResetPasswordForm>,
) -> impl IntoResponse {
    if let Some(r) = ensure_owner(&state, &jar) {
        return r.into_response();
    }
    if form.new_password.trim().is_empty() {
        return plain_html("Password cannot be empty");
    }
    let uname = username.to_lowercase();
    let mut users = state.users.lock().unwrap();
    if let Some(rec) = users.get_mut(&uname) {
        rec.password = generate_password_hash(&form.new_password);
    } else {
        return plain_html("User not found");
    }
    let mut serialized: serde_json::Map<String, Value> = serde_json::Map::new();
    for (u, rec) in users.iter() {
        serialized.insert(u.clone(), serde_json::json!({"password": rec.password, "role": rec.role, "assigned_instances": rec.assigned_instances }));
    }
    let _ = std::fs::write(
        "users.json",
        serde_json::to_string_pretty(&Value::Object(serialized)).unwrap(),
    );
    Redirect::to("/users").into_response()
}

#[derive(Deserialize)]
struct UpdateRoleForm {
    role: String,
}
async fn update_role(
    State(state): State<AppState>,
    jar: CookieJar,
    axum::extract::Path(username): axum::extract::Path<String>,
    Form(form): Form<UpdateRoleForm>,
) -> impl IntoResponse {
    // Only owners may update roles
    if let Some(r) = ensure_owner(&state, &jar) {
        return r.into_response();
    }
    let uname = username.to_lowercase();
    if form.role != "owner" && form.role != "admin" {
        return plain_html("Invalid role");
    }
    let mut users = state.users.lock().unwrap();
    // First check if user exists and compute role-change safety checks without a mutable borrow
    let current_role = match users.get(&uname) {
        Some(r) => r.role.clone(),
        None => return plain_html("User not found"),
    };
    if current_role == "owner" && form.role != "owner" {
        let remaining_owners = users
            .iter()
            .filter(|(n, r)| r.role == "owner" && n.as_str() != uname)
            .count();
        if remaining_owners == 0 {
            return plain_html("At least one owner required");
        }
    }
    // Now perform mutable update
    if let Some(rec) = users.get_mut(&uname) {
        rec.role = form.role.clone();
    }
    let mut serialized: serde_json::Map<String, Value> = serde_json::Map::new();
    for (u, r) in users.iter() {
        serialized.insert(u.clone(), serde_json::json!({"password": r.password, "role": r.role, "assigned_instances": r.assigned_instances }));
    }
    let _ = std::fs::write(
        "users.json",
        serde_json::to_string_pretty(&Value::Object(serialized)).unwrap(),
    );
    Redirect::to("/users").into_response()
}
// The old immediate-action handlers (instance_poweron, instance_poweroff, instance_reset) were removed
// in favor of explicit confirmation pages and dedicated POST handlers (e.g., instance_poweron_get/post).

async fn delete_user(
    State(state): State<AppState>,
    jar: CookieJar,
    axum::extract::Path(username): axum::extract::Path<String>,
) -> impl IntoResponse {
    if let Some(r) = ensure_owner(&state, &jar) {
        return r.into_response();
    }
    let current = current_username_from_jar(&state, &jar).unwrap_or_default();
    let uname = username.to_lowercase();
    let mut users = state.users.lock().unwrap();
    if uname == current {
        return plain_html("Cannot delete own account");
    }
    if let Some(rec) = users.get(&uname) {
        if rec.role == "owner" {
            let owners = users
                .iter()
                .filter(|(name, r)| r.role == "owner" && name.as_str() != uname)
                .count();
            if owners == 0 {
                return plain_html("At least one owner required");
            }
        }
    }
    if users.remove(&uname).is_none() {
        return plain_html("User not found");
    }
    let mut serialized: serde_json::Map<String, Value> = serde_json::Map::new();
    for (u, rec) in users.iter() {
        serialized.insert(u.clone(), serde_json::json!({"password": rec.password, "role": rec.role, "assigned_instances": rec.assigned_instances }));
    }
    let _ = std::fs::write(
        "users.json",
        serde_json::to_string_pretty(&Value::Object(serialized)).unwrap(),
    );
    Redirect::to("/users").into_response()
}
#[derive(Template)]
#[template(path = "instances.html")]
struct InstancesTemplate<'a> {
    current_user: Option<CurrentUser>,
    api_hostname: String,
    base_url: String,
    flash_messages: Vec<String>,
    has_flash_messages: bool,
    instances: &'a [InstanceView],
}


#[derive(Clone)]
struct InstanceForAction {
    id: String,
    hostname: String,
    region: String,
    main_ip: Option<String>,
    status: String,
    vcpu_count_display: String,
    ram_display: String,
    disk_display: String,
    os: Option<OsItem>,
}

#[derive(Template)]
#[template(path = "poweroff_instance.html")]
struct PowerOffInstanceTemplate {
    current_user: Option<CurrentUser>,
    api_hostname: String,
    base_url: String,
    flash_messages: Vec<String>,
    has_flash_messages: bool,
    instance: InstanceForAction,
    is_disabled: bool,
}

#[derive(Template)]
#[template(path = "poweron_instance.html")]
struct PowerOnInstanceTemplate {
    current_user: Option<CurrentUser>,
    api_hostname: String,
    base_url: String,
    flash_messages: Vec<String>,
    has_flash_messages: bool,
    instance: InstanceForAction,
    is_disabled: bool,
}

#[derive(Template)]
#[template(path = "reset_instance.html")]
struct ResetInstanceTemplate {
    current_user: Option<CurrentUser>,
    api_hostname: String,
    base_url: String,
    flash_messages: Vec<String>,
    has_flash_messages: bool,
    instance: InstanceForAction,
    is_disabled: bool,
}

#[derive(Template)]
#[template(path = "delete_instance.html")]
struct DeleteInstanceTemplate {
    current_user: Option<CurrentUser>,
    api_hostname: String,
    base_url: String,
    flash_messages: Vec<String>,
    has_flash_messages: bool,
    instance: InstanceForAction,
    is_disabled: bool,
}

#[derive(Template)]
#[template(path = "change_os.html")]
struct ChangeOsTemplate<'a> {
    current_user: Option<CurrentUser>,
    api_hostname: String,
    base_url: String,
    flash_messages: Vec<String>,
    has_flash_messages: bool,
    instance: InstanceForAction,
    os_list: &'a [OsItem],
    is_disabled: bool,
}

#[derive(Template)]
#[template(path = "resize.html")]
struct ResizeTemplate<'a> {
    current_user: Option<CurrentUser>,
    api_hostname: String,
    base_url: String,
    flash_messages: Vec<String>,
    has_flash_messages: bool,
    instance: InstanceForAction,
    regions: &'a [Region],
    is_disabled: bool,
}

#[derive(Template)]
#[template(path = "change_pass_instance.html")]
struct ChangePassInstanceTemplate {
    current_user: Option<CurrentUser>,
    api_hostname: String,
    base_url: String,
    flash_messages: Vec<String>,
    has_flash_messages: bool,
    instance: InstanceForAction,
    new_password: Option<String>,
    is_disabled: bool,
}

async fn load_instances_for_user(state: &AppState, username: &str) -> Vec<InstanceView> {
    let payload = api_call(state, "GET", "/v1/instances", None, None).await;
    let mut list: Vec<InstanceView> = vec![];
    if payload.get("code").and_then(|c| c.as_str()) == Some("OKAY") {
        if let Some(items) = payload
            .get("data")
            .and_then(|d| d.get("instances"))
            .and_then(|arr| arr.as_array())
        {
            for item in items {
                let id = item
                    .get("id")
                    .and_then(|v| v.as_i64())
                    .map(|n| n.to_string())
                    .or_else(|| {
                        item.get("id")
                            .and_then(|v| v.as_str())
                            .map(|s| s.to_string())
                    })
                    .unwrap_or_else(|| "?".into());
                let hostname = item
                    .get("hostname")
                    .and_then(|v| v.as_str())
                    .map(|s| s.to_string())
                    .unwrap_or_else(|| "(no hostname)".into());
                let status = item
                    .get("status")
                    .and_then(|v| v.as_str())
                    .map(|s| s.to_string())
                    .unwrap_or_else(|| "?".into());
                list.push(InstanceView { id, hostname, status });
            }
        }
    }
    let (role, allowed) = {
        let users = state.users.lock().unwrap();
        if let Some(user) = users.get(username) {
            if user.role == "admin" {
                (
                    Some(user.role.clone()),
                    Some(
                        user.assigned_instances
                            .iter()
                            .cloned()
                            .collect::<HashSet<String>>(),
                    ),
                )
            } else {
                (Some(user.role.clone()), None)
            }
        } else {
            (None, None)
        }
    };
    if role.as_deref() == Some("admin") {
        if let Some(allowed_set) = allowed {
            list.retain(|inst| allowed_set.contains(&inst.id));
        }
    }
    list
}

async fn instances_real(State(state): State<AppState>, jar: CookieJar) -> impl IntoResponse {
    let Some(username) = current_username_from_jar(&state, &jar) else {
        return Redirect::to("/login").into_response();
    };
    let list = load_instances_for_user(&state, &username).await;
    let TemplateGlobals { current_user, api_hostname, base_url, flash_messages, has_flash_messages } = build_template_globals(&state, &jar);
    inject_context(
        &state,
        &jar,
        InstancesTemplate {
            current_user,
            api_hostname,
            base_url,
            flash_messages,
            has_flash_messages,
            instances: &list,
        }
        .render()
        .unwrap(),
    )
}

// Access management (owner only): list admins and assign instances
#[derive(Template)]
#[template(path = "access.html")]
struct AccessTemplate {
    current_user: Option<CurrentUser>,
    api_hostname: String,
    base_url: String,
    flash_messages: Vec<String>,
    has_flash_messages: bool,
    admins: Vec<AdminView>,
}

struct AdminView {
    username: String,
    instances: Vec<AdminInstanceRow>,
}

struct AdminInstanceRow {
    id: String,
    hostname: String,
    checked: bool,
}

async fn access_get(State(state): State<AppState>, jar: CookieJar) -> impl IntoResponse {
    if let Some(r) = ensure_owner(&state, &jar) {
        return r.into_response();
    }
    // Load instances
    let payload = api_call(&state, "GET", "/v1/instances", None, None).await;
    let mut list: Vec<InstanceView> = vec![];
    if payload.get("code").and_then(|c| c.as_str()) == Some("OKAY") {
        if let Some(items) = payload
            .get("data")
            .and_then(|d| d.get("instances"))
            .and_then(|arr| arr.as_array())
        {
            for item in items {
                let id = item
                    .get("id")
                    .and_then(|v| v.as_i64())
                    .map(|n| n.to_string())
                    .or_else(|| {
                        item.get("id")
                            .and_then(|v| v.as_str())
                            .map(|s| s.to_string())
                    })
                    .unwrap_or_else(|| "?".into());
                let hostname = item
                    .get("hostname")
                    .and_then(|v| v.as_str())
                    .map(|s| s.to_string())
                    .unwrap_or_else(|| "(no hostname)".into());
                let status = item
                    .get("status")
                    .and_then(|v| v.as_str())
                    .map(|s| s.to_string())
                    .unwrap_or_else(|| "?".into());
                list.push(InstanceView { id, hostname, status });
            }
        }
    }
    // Collect admins
    let users = state.users.lock().unwrap();
    let mut admins: Vec<AdminView> = users
        .iter()
        .filter(|(_, rec)| rec.role == "admin")
        .map(|(u, rec)| {
            let assigned: HashSet<&str> =
                rec.assigned_instances.iter().map(|s| s.as_str()).collect();
            let rows = list
                .iter()
                .map(|inst| {
                    let checked = assigned.contains(inst.id.as_str());
                    AdminInstanceRow {
                        id: inst.id.clone(),
                        hostname: inst.hostname.clone(),
                        checked,
                    }
                })
                .collect();
            AdminView {
                username: u.clone(),
                instances: rows,
            }
        })
        .collect();
    admins.sort_by(|a, b| a.username.cmp(&b.username));
    let TemplateGlobals {
        current_user,
        api_hostname,
        base_url,
        flash_messages,
        has_flash_messages,
    } = build_template_globals(&state, &jar);
    inject_context(
        &state,
        &jar,
        AccessTemplate { current_user, api_hostname, base_url, flash_messages, has_flash_messages, admins }.render().unwrap(),
    )
}

#[derive(Deserialize)]
struct UpdateAccessForm {
    #[serde(rename = "instances")]
    instances: Vec<String>,
}

async fn update_access(
    State(state): State<AppState>,
    jar: CookieJar,
    axum::extract::Path(username): axum::extract::Path<String>,
    Form(form): Form<UpdateAccessForm>,
) -> impl IntoResponse {
    if let Some(r) = ensure_owner(&state, &jar) {
        return r.into_response();
    }
    let uname = username.to_lowercase();
    let mut users = state.users.lock().unwrap();
    if let Some(rec) = users.get_mut(&uname) {
        if rec.role != "admin" {
            return plain_html("Target user not admin");
        }
        // Normalize and dedupe
        let mut normalized: Vec<String> = form
            .instances
            .iter()
            .map(|s| s.trim().to_string())
            .filter(|s| !s.is_empty())
            .collect();
        normalized.sort();
        normalized.dedup();
        rec.assigned_instances = normalized;
        let mut serialized: serde_json::Map<String, Value> = serde_json::Map::new();
        for (u, r) in users.iter() {
            serialized.insert(u.clone(), serde_json::json!({"password": r.password, "role": r.role, "assigned_instances": r.assigned_instances }));
        }
        let _ = std::fs::write(
            "users.json",
            serde_json::to_string_pretty(&Value::Object(serialized)).unwrap(),
        );
    } else {
        return plain_html("Admin not found");
    }
    Redirect::to("/access").into_response()
}
// SSH Keys CRUD (owner only)
#[derive(Serialize, Deserialize, Clone)]
struct SshKeyView {
    id: String,
    name: String,
    fingerprint: String,
    public_key: String,
    customer_id: Option<String>,
}

#[derive(Template)]
#[template(path = "ssh_keys.html")]
struct SshKeysTemplate<'a> {
    current_user: Option<CurrentUser>,
    api_hostname: String,
    base_url: String,
    flash_messages: Vec<String>,
    has_flash_messages: bool,
    ssh_keys: &'a [SshKeyView],
    customer_id: Option<String>,
}

#[derive(Deserialize)]
struct SshKeysForm {
    action: Option<String>,
    name: Option<String>,
    public_key: Option<String>,
    ssh_key_id: Option<String>,
}

fn detail_requires_customer(detail: &str) -> bool {
    detail.to_lowercase().contains("customer id")
}

fn extract_customer_id_from_value(value: &Value) -> Option<String> {
    fn recurse(node: &Value) -> Option<String> {
        if let Some(obj) = node.as_object() {
            for key in ["customerId", "customer_id", "id"] {
                if let Some(val) = obj.get(key).and_then(|v| v.as_str()) {
                    let trimmed = val.trim();
                    if !trimmed.is_empty() {
                        return Some(trimmed.to_string());
                    }
                }
            }
            for key in ["customer", "data"] {
                if let Some(child) = obj.get(key) {
                    if let Some(found) = recurse(child) {
                        return Some(found);
                    }
                }
            }
            for key in ["customers", "items", "records", "results"] {
                if let Some(arr) = obj.get(key).and_then(|v| v.as_array()) {
                    for entry in arr {
                        if let Some(found) = recurse(entry) {
                            return Some(found);
                        }
                    }
                }
            }
        } else if let Some(arr) = node.as_array() {
            for entry in arr {
                if let Some(found) = recurse(entry) {
                    return Some(found);
                }
            }
        }
        None
    }

    if let Some(data) = value.get("data") {
        if let Some(found) = recurse(data) {
            return Some(found);
        }
    }
    recurse(value)
}

async fn fetch_default_customer_id(state: &AppState) -> Option<String> {
    if let Some(existing) = state.default_customer_cache.lock().unwrap().clone() {
        return Some(existing);
    }
    let endpoints = ["/v1/customers", "/v1/profile"];
    for endpoint in endpoints {
        let payload = api_call(state, "GET", endpoint, None, None).await;
        if let Some(id) = extract_customer_id_from_value(&payload) {
            let mut cache = state.default_customer_cache.lock().unwrap();
            *cache = Some(id.clone());
            return Some(id);
        }
    }
    None
}

async fn load_ssh_keys_api(state: &AppState, customer_id: Option<String>) -> Vec<SshKeyView> {
    let params = customer_id.map(|cid| vec![("customerId".to_string(), cid)]);
    let payload = api_call(state, "GET", "/v1/ssh-keys", None, params).await;
    if payload.get("code").and_then(|c| c.as_str()) != Some("OKAY") {
        return vec![];
    }
    let data = payload.get("data").cloned().unwrap_or(Value::Null);
    let candidates: Vec<Value> = if let Some(arr) = data.as_array() {
        arr.clone()
    } else if let Some(arr) = data.get("sshKeys").and_then(|v| v.as_array()) {
        arr.clone()
    } else {
        vec![]
    };
    let mut out = vec![];
    for item in candidates {
        if let Some(obj) = item.as_object() {
            let id = obj
                .get("id")
                .and_then(|v| v.as_i64())
                .map(|n| n.to_string())
                .or_else(|| {
                    obj.get("id")
                        .and_then(|v| v.as_str())
                        .map(|s| s.to_string())
                })
                .unwrap_or_else(|| "0".into());
            let name = obj
                .get("name")
                .and_then(|v| v.as_str())
                .map(|s| s.to_string())
                .unwrap_or_else(|| format!("SSH Key {}", id));
            let fingerprint = obj
                .get("fingerprint")
                .or_else(|| obj.get("fingerPrint"))
                .and_then(|v| v.as_str())
                .unwrap_or("")
                .to_string();
            let public_key = obj
                .get("publicKey")
                .or_else(|| obj.get("public_key"))
                .and_then(|v| v.as_str())
                .unwrap_or("")
                .to_string();
            let customer_id = obj
                .get("customerId")
                .or_else(|| obj.get("userId"))
                .or_else(|| obj.get("customer_id"))
                .and_then(|v| v.as_str())
                .map(|s| s.to_string());
            out.push(SshKeyView {
                id,
                name,
                fingerprint,
                public_key,
                customer_id,
            });
        }
    }
    out
}

async fn ssh_keys_get(
    State(state): State<AppState>,
    jar: CookieJar,
    axum::extract::Query(q): axum::extract::Query<HashMap<String, String>>,
) -> impl IntoResponse {
    if let Some(r) = ensure_owner(&state, &jar) {
        return r.into_response();
    }
    let customer_id = if let Some(id) = q.get("customer_id").cloned() {
        Some(id)
    } else {
        fetch_default_customer_id(&state).await
    };
    let keys = load_ssh_keys_api(&state, customer_id.clone()).await;
    let TemplateGlobals { current_user, api_hostname, base_url, flash_messages, has_flash_messages } = build_template_globals(&state, &jar);
    inject_context(
        &state,
        &jar,
        SshKeysTemplate {
            current_user,
            api_hostname,
            base_url,
            flash_messages,
            has_flash_messages,
            ssh_keys: &keys,
            customer_id,
        }
        .render()
        .unwrap(),
    )
}

async fn ssh_keys_post(
    State(state): State<AppState>,
    jar: CookieJar,
    Form(form): Form<SshKeysForm>,
) -> impl IntoResponse {
    if let Some(r) = ensure_owner(&state, &jar) {
        return r.into_response();
    }
    let action = form.action.clone().unwrap_or_else(|| "create".into());
    if action == "delete" {
        let key_id_raw = form.ssh_key_id.clone().unwrap_or_default();
        if !key_id_raw.chars().all(|c| c.is_ascii_digit()) {
            return plain_html("Invalid key id");
        }
        let endpoint = format!("/v1/ssh-keys/{}", key_id_raw);
        let payload = api_call(&state, "DELETE", &endpoint, None, None).await;
        if payload.get("code").and_then(|c| c.as_str()) != Some("OKAY") {
            if let Some(detail) = payload.get("detail").and_then(|d| d.as_str()) {
                if detail_requires_customer(detail) {
                    if let Some(cid) = fetch_default_customer_id(&state).await {
                        let _ = api_call(
                            &state,
                            "DELETE",
                            &endpoint,
                            None,
                            Some(vec![("customerId".into(), cid)]),
                        )
                        .await;
                    }
                }
            }
        }
        return Redirect::to("/ssh-keys").into_response();
    }
    let name = form.name.clone().unwrap_or_default().trim().to_string();
    let public_key = form
        .public_key
        .clone()
        .unwrap_or_default()
        .trim()
        .to_string();
    if name.is_empty() || public_key.is_empty() {
        return plain_html("Provide name and public key");
    }
    let mut body = serde_json::json!({"name": name, "publicKey": public_key});
    let payload = api_call(&state, "POST", "/v1/ssh-keys", Some(body.clone()), None).await;
    if payload.get("code").and_then(|c| c.as_str()) != Some("OKAY") {
        if let Some(detail) = payload.get("detail").and_then(|d| d.as_str()) {
            if detail_requires_customer(detail) {
                if let Some(cid) = fetch_default_customer_id(&state).await {
                    body["customerId"] = Value::String(cid.clone());
                    let _ = api_call(&state, "POST", "/v1/ssh-keys", Some(body), None).await;
                }
            }
        }
    }
    Redirect::to("/ssh-keys").into_response()
}

// Regions are rendered using `templates/regions.html` (path-based Askama template)

// Products are rendered using `templates/products.html` (path-based Askama template)

// OS catalog is rendered using `templates/os.html` (path-based Askama template)

// Applications are rendered using `templates/applications.html` (path-based Askama template)

async fn root_get(State(state): State<AppState>, jar: CookieJar) -> impl IntoResponse {
    // Redirect to /instances if authenticated, otherwise to /login
    if let Some(_uname) = current_username_from_jar(&state, &jar) {
        return Redirect::to("/instances").into_response();
    }
    Redirect::to("/login").into_response()
}

async fn regions_get(State(state): State<AppState>, jar: CookieJar) -> impl IntoResponse {
    if let Some(r) = ensure_owner(&state, &jar) {
        return r.into_response();
    }
    let (regions, _) = load_regions(&state).await;
    // let total_regions = regions.len();
    // let premium_count = regions.iter().filter(|r| r.is_premium).count();
    let TemplateGlobals { current_user, api_hostname, base_url, flash_messages, has_flash_messages } = build_template_globals(&state, &jar);
    let html = RegionsPageTemplate {
        current_user,
        api_hostname,
        base_url,
        flash_messages,
        has_flash_messages,
        regions: &regions,
    }
    .render()
    .unwrap();
    inject_context(&state, &jar, html)
}

async fn products_get(
    State(state): State<AppState>,
    jar: CookieJar,
    axum::extract::Query(q): axum::extract::Query<HashMap<String, String>>,
) -> impl IntoResponse {
    if let Some(r) = ensure_owner(&state, &jar) {
        return r.into_response();
    }
    let (regions, _) = load_regions(&state).await;
    let region_param = q
        .get("region_id")
        .cloned()
        .or_else(|| q.get("region").cloned())
        .or_else(|| q.get("regionId").cloned());
    let mut requested_region = None;
    let mut selected_region_idx: Option<usize> = None;
    if let Some(ref rid) = region_param {
        selected_region_idx = regions.iter().position(|r| r.id == rid.as_str());
        if selected_region_idx.is_none() {
            requested_region = Some(rid.clone());
        }
    } else if !regions.is_empty() {
        selected_region_idx = Some(0);
    }
    let selected_region_id = selected_region_idx.map(|idx| regions[idx].id.clone());
    let products = if let Some(ref region_id) = selected_region_id {
        load_products(&state, region_id).await
    } else {
        vec![]
    };
    let selected_region = selected_region_idx.map(|idx| &regions[idx]);
    let active_region_id = selected_region_id.clone().unwrap_or_default();
    let TemplateGlobals { current_user, api_hostname, base_url, flash_messages, has_flash_messages } = build_template_globals(&state, &jar);
    let html = ProductsPageTemplate {
        current_user,
        api_hostname,
        base_url,
        flash_messages,
        has_flash_messages,
        regions: &regions,
        selected_region,
        active_region_id,
        requested_region,
        products: &products,
    }
    .render()
    .unwrap();
    inject_context(&state, &jar, html)
}

async fn os_get(State(state): State<AppState>, jar: CookieJar) -> impl IntoResponse {
    if let Some(r) = ensure_owner(&state, &jar) {
        return r.into_response();
    }
    let os_list = load_os_list(&state).await;
    // let total_images = os_list.len();
    let TemplateGlobals { current_user, api_hostname, base_url, flash_messages, has_flash_messages } = build_template_globals(&state, &jar);
    let html = OsCatalogTemplate {
        current_user,
        api_hostname,
        base_url,
        flash_messages,
        has_flash_messages,
        os_list: &os_list,
    }
    .render()
    .unwrap();
    inject_context(&state, &jar, html)
}

async fn applications_get(State(state): State<AppState>, jar: CookieJar) -> impl IntoResponse {
    if let Some(r) = ensure_owner(&state, &jar) {
        return r.into_response();
    }
    let apps = load_applications(&state).await;
    // let total_apps = apps.len();
    let TemplateGlobals { current_user, api_hostname, base_url, flash_messages, has_flash_messages } = build_template_globals(&state, &jar);
    let html = ApplicationsTemplate {
        current_user,
        api_hostname,
        base_url,
        flash_messages,
        has_flash_messages,
        apps: &apps,
    }
    .render()
    .unwrap();
    inject_context(&state, &jar, html)
}

// ---------- Instance Detail & Actions ----------
// Instance details are rendered using `templates/instance_detail.html` (path-based Askama template)

async fn enforce_instance_access(state: &AppState, jar: &CookieJar, instance_id: &str) -> bool {
    if let Some(username) = current_username_from_jar(state, jar) {
        let users = state.users.lock().unwrap();
        if let Some(rec) = users.get(&username) {
            if rec.role == "owner" {
                return true;
            }
            return rec.assigned_instances.iter().any(|id| id == instance_id);
        }
    }
    false
}

async fn instance_detail(
    State(state): State<AppState>,
    jar: CookieJar,
    axum::extract::Path(instance_id): axum::extract::Path<String>,
) -> impl IntoResponse {
    if let Some(r) = ensure_logged_in(&state, &jar) {
        return r.into_response();
    }
    if let Some(r) = ensure_logged_in(&state, &jar) {
        return r.into_response();
    }
    if !enforce_instance_access(&state, &jar, &instance_id).await {
        return Redirect::to("/instances").into_response();
    }
    let endpoint = format!("/v1/instances/{}", instance_id);
    let payload = api_call(&state, "GET", &endpoint, None, None).await;
    let _json = serde_json::to_string_pretty(&payload).unwrap_or_else(|_| "{}".into());
    // Collect nice key-value pair details we want to display rather than raw JSON
    let mut details: Vec<(String, String)> = Vec::new();
    let mut hostname = "(no hostname)".to_string();
    if let Some(obj) = payload.as_object() {
        if let Some(data) = obj.get("data").and_then(|d| d.as_object()) {
            hostname = data
                .get("hostname")
                .and_then(|v| v.as_str())
                .unwrap_or("(no hostname)")
                .to_string();
            details.push(("Hostname".into(), hostname.clone()));
            let status = data
                .get("status")
                .and_then(|v| v.as_str())
                .unwrap_or("")
                .to_string();
            details.push(("Status".into(), status));
            let region = data
                .get("region")
                .and_then(|v| v.as_str())
                .unwrap_or("")
                .to_string();
            details.push(("Region".into(), region.clone()));
            let class = data
                .get("class")
                .and_then(|v| v.as_str())
                .unwrap_or("")
                .to_string();
            details.push(("Instance class".into(), class));
            let product_id = data
                .get("productId")
                .and_then(|v| v.as_str())
                .map(|s| s.to_string());
            if let Some(pid) = product_id.clone() {
                // Try to resolve product name using region-scoped product listing
                let product_name = if !region.is_empty() && !pid.is_empty() {
                    let products = load_products(&state, &region).await;
                    products
                        .into_iter()
                        .find(|p| p.id == pid)
                        .map(|p| p.name)
                        .unwrap_or(pid.clone())
                } else {
                    pid.clone()
                };
                details.push(("Product".into(), product_name));
            }
            let vcpu = data.get("vcpuCount").and_then(|v| v.as_i64()).map(|v| v.to_string());
            if let Some(x) = vcpu { details.push(("vCPU".into(), x)); }
            let ram = data.get("ram").and_then(|v| v.as_i64()).map(|v| format!("{} MB", v));
            if let Some(x) = ram { details.push(("RAM".into(), x)); }
            let disk = data.get("disk").and_then(|v| v.as_i64()).map(|v| format!("{} GB", v));
            if let Some(x) = disk { details.push(("Disk".into(), x)); }
            let ip = data.get("mainIp").and_then(|v| v.as_str()).map(|s| s.to_string());
            if let Some(x) = ip { details.push(("IPv4".into(), x)); }
            let ip6 = data.get("mainIpv6").and_then(|v| v.as_str()).map(|s| s.to_string());
            if let Some(x) = ip6 { details.push(("IPv6".into(), x)); }
            if let Some(os_obj) = data.get("os") {
                let os_name = os_obj
                    .get("name")
                    .and_then(|v| v.as_str())
                    .or_else(|| os_obj.get("id").and_then(|v| v.as_str()))
                    .unwrap_or("")
                    .to_string();
                if !os_name.is_empty() { details.push(("OS".into(), os_name)); }
            }
            if let Some(inserted) = data.get("insertedAt").and_then(|v| v.as_str()).map(|s| s.to_string()) {
                details.push(("Created".into(), inserted));
            }
            if let Some(features) = data.get("features").and_then(|v| v.as_array()) {
                let mut features_list = Vec::new();
                for item in features { if let Some(s) = item.as_str() { features_list.push(s.to_string()); } }
                if !features_list.is_empty() { details.push(("Features".into(), features_list.join(", "))); }
            }
        }
    }
    let TemplateGlobals { current_user, api_hostname, base_url, flash_messages, has_flash_messages } = build_template_globals(&state, &jar);
    inject_context(
        &state,
        &jar,
        InstanceDetailTemplate {
            current_user,
            api_hostname,
            base_url,
            flash_messages,
            has_flash_messages,
            instance_id: instance_id.clone(),
            hostname,
            details,
            is_disabled: state.is_instance_disabled(&instance_id),
        }
        .render()
        .unwrap(),
    )
}


// immediate instance_poweron action removed; use confirmation GET/POST handlers instead

async fn instance_poweron_get(
    State(state): State<AppState>,
    jar: CookieJar,
    axum::extract::Path(instance_id): axum::extract::Path<String>,
) -> impl IntoResponse {
    if let Some(r) = ensure_logged_in(&state, &jar) {
        return r.into_response();
    }
    if !enforce_instance_access(&state, &jar, &instance_id).await {
        return Redirect::to("/instances").into_response();
    }
    let endpoint = format!("/v1/instances/{}", instance_id);
    let payload = api_call(&state, "GET", &endpoint, None, None).await;
    let mut instance = InstanceForAction { id: instance_id.clone(), hostname: "(no hostname)".into(), region: "".into(), main_ip: None, status: "".into(), vcpu_count_display: "".into(), ram_display: "".into(), disk_display: "".into(), os: None };
    if let Some(obj) = payload.as_object() {
        if let Some(data) = obj.get("data").and_then(|d| d.as_object()) {
            instance.hostname = data.get("hostname").and_then(|v| v.as_str()).unwrap_or(&instance.hostname).to_string();
            instance.vcpu_count_display = data.get("vcpuCount").and_then(|v| v.as_i64()).map(|n| n.to_string()).unwrap_or_else(|| "".into());
            instance.ram_display = data.get("ram").and_then(|v| v.as_i64()).map(|n| format!("{} MB", n)).unwrap_or_else(|| "".into());
            instance.disk_display = data.get("disk").and_then(|v| v.as_i64()).map(|n| format!("{} GB", n)).unwrap_or_else(|| "".into());
            if let Some(os_obj) = data.get("os").and_then(|v| v.as_object()) {
                instance.os = Some(OsItem {
                    id: os_obj.get("id").and_then(|v| v.as_str()).unwrap_or("").to_string(),
                    name: os_obj.get("name").and_then(|v| v.as_str()).unwrap_or("").to_string(),
                    family: os_obj.get("family").and_then(|v| v.as_str()).unwrap_or("").to_string(),
                    arch: os_obj.get("arch").and_then(|v| v.as_str()).map(|s| s.to_string()),
                    min_ram: os_obj.get("minRam").and_then(|v| v.as_str()).map(|s| s.to_string()),
                    is_default: os_obj.get("isDefault").and_then(|v| v.as_bool()).unwrap_or(false),
                });
            }
            instance.region = data.get("region").and_then(|v| v.as_str()).unwrap_or("").to_string();
            instance.main_ip = data.get("mainIp").and_then(|v| v.as_str()).map(|s| s.to_string());
            instance.status = data.get("status").and_then(|v| v.as_str()).unwrap_or("").to_string();
        }
    }
    let TemplateGlobals { current_user, api_hostname, base_url, flash_messages, has_flash_messages } = build_template_globals(&state, &jar);
    inject_context(&state, &jar, PowerOnInstanceTemplate { current_user, api_hostname, base_url, flash_messages, has_flash_messages, instance, is_disabled: state.is_instance_disabled(&instance_id) }.render().unwrap())
}

// POST handler for poweron
async fn instance_poweron_post(
    State(state): State<AppState>,
    jar: CookieJar,
    axum::extract::Path(instance_id): axum::extract::Path<String>,
) -> impl IntoResponse {
    if let Some(r) = ensure_logged_in(&state, &jar) {
        return r.into_response();
    }
    if !enforce_instance_access(&state, &jar, &instance_id).await {
        return Redirect::to("/instances").into_response();
    }
    if state.is_instance_disabled(&instance_id) {
        if let Some(sid) = jar.get("session_id") {
            let mut flashes = state.flash_store.lock().unwrap();
            let entry = flashes.entry(sid.value().to_string()).or_default();
            entry.push("Actions are disabled for this instance.".into());
        }
        return Redirect::to(&format!("/instance/{}", instance_id)).into_response();
    }
    let _ = simple_instance_action(&state, "poweron", &instance_id).await;
    Redirect::to(&format!("/instance/{}", instance_id)).into_response()
}
// immediate instance_poweroff action removed; use confirmation GET/POST handlers instead
// immediate instance_reset action removed; use confirmation GET/POST handlers instead

// Render confirm page for delete (GET) and perform delete (POST implemented as instance_delete)
async fn instance_delete_get(
    State(state): State<AppState>,
    jar: CookieJar,
    axum::extract::Path(instance_id): axum::extract::Path<String>,
) -> impl IntoResponse {
    if let Some(r) = ensure_logged_in(&state, &jar) {
        return r.into_response();
    }
    if !enforce_instance_access(&state, &jar, &instance_id).await {
        return Redirect::to("/instances").into_response();
    }
    let endpoint = format!("/v1/instances/{}", instance_id);
    let payload = api_call(&state, "GET", &endpoint, None, None).await;
    let mut instance = InstanceForAction { id: instance_id.clone(), hostname: "(no hostname)".into(), region: "".into(), main_ip: None, status: "".into(), vcpu_count_display: "".into(), ram_display: "".into(), disk_display: "".into(), os: None };
    if let Some(obj) = payload.as_object() {
        if let Some(data) = obj.get("data").and_then(|d| d.as_object()) {
            instance.hostname = data.get("hostname").and_then(|v| v.as_str()).unwrap_or(&instance.hostname).to_string();
            instance.vcpu_count_display = data.get("vcpuCount").and_then(|v| v.as_i64()).map(|n| n.to_string()).unwrap_or_else(|| "".into());
            instance.ram_display = data.get("ram").and_then(|v| v.as_i64()).map(|n| format!("{} MB", n)).unwrap_or_else(|| "".into());
            instance.disk_display = data.get("disk").and_then(|v| v.as_i64()).map(|n| format!("{} GB", n)).unwrap_or_else(|| "".into());
            if let Some(os_obj) = data.get("os").and_then(|v| v.as_object()) {
                instance.os = Some(OsItem {
                    id: os_obj.get("id").and_then(|v| v.as_str()).unwrap_or("").to_string(),
                    name: os_obj.get("name").and_then(|v| v.as_str()).unwrap_or("").to_string(),
                    family: os_obj.get("family").and_then(|v| v.as_str()).unwrap_or("").to_string(),
                    arch: os_obj.get("arch").and_then(|v| v.as_str()).map(|s| s.to_string()),
                    min_ram: os_obj.get("minRam").and_then(|v| v.as_str()).map(|s| s.to_string()),
                    is_default: os_obj.get("isDefault").and_then(|v| v.as_bool()).unwrap_or(false),
                });
            }
            instance.region = data.get("region").and_then(|v| v.as_str()).unwrap_or("").to_string();
            instance.main_ip = data.get("mainIp").and_then(|v| v.as_str()).map(|s| s.to_string());
            instance.status = data.get("status").and_then(|v| v.as_str()).unwrap_or("").to_string();
            instance.vcpu_count_display = data.get("vcpuCount").and_then(|v| v.as_i64()).map(|n| n.to_string()).unwrap_or_else(|| "".into());
            instance.ram_display = data.get("ram").and_then(|v| v.as_i64()).map(|n| format!("{} MB", n)).unwrap_or_else(|| "".into());
            instance.disk_display = data.get("disk").and_then(|v| v.as_i64()).map(|n| format!("{} GB", n)).unwrap_or_else(|| "".into());
        }
    }
    let TemplateGlobals { current_user, api_hostname, base_url, flash_messages, has_flash_messages } = build_template_globals(&state, &jar);
    inject_context(&state, &jar, DeleteInstanceTemplate { current_user, api_hostname, base_url, flash_messages, has_flash_messages, instance, is_disabled: state.is_instance_disabled(&instance_id) }.render().unwrap())
}

// Render confirm page for poweroff (GET) and perform poweroff (POST handler below)
async fn instance_poweroff_get(
    State(state): State<AppState>,
    jar: CookieJar,
    axum::extract::Path(instance_id): axum::extract::Path<String>,
) -> impl IntoResponse {
    if let Some(r) = ensure_logged_in(&state, &jar) {
        return r.into_response();
    }
    if !enforce_instance_access(&state, &jar, &instance_id).await {
        return Redirect::to("/instances").into_response();
    }
    let endpoint = format!("/v1/instances/{}", instance_id);
    let payload = api_call(&state, "GET", &endpoint, None, None).await;
    let mut instance = InstanceForAction { id: instance_id.clone(), hostname: "(no hostname)".into(), region: "".into(), main_ip: None, status: "".into(), vcpu_count_display: "".into(), ram_display: "".into(), disk_display: "".into(), os: None };
    if let Some(obj) = payload.as_object() {
        if let Some(data) = obj.get("data").and_then(|d| d.as_object()) {
            instance.hostname = data.get("hostname").and_then(|v| v.as_str()).unwrap_or(&instance.hostname).to_string();
            instance.region = data.get("region").and_then(|v| v.as_str()).unwrap_or("").to_string();
            instance.main_ip = data.get("mainIp").and_then(|v| v.as_str()).map(|s| s.to_string());
            instance.status = data.get("status").and_then(|v| v.as_str()).unwrap_or("").to_string();
        }
    }
    let TemplateGlobals { current_user, api_hostname, base_url, flash_messages, has_flash_messages } = build_template_globals(&state, &jar);
    inject_context(&state, &jar, PowerOffInstanceTemplate { current_user, api_hostname, base_url, flash_messages, has_flash_messages, instance, is_disabled: state.is_instance_disabled(&instance_id) }.render().unwrap())
}

// POST handler for poweroff
async fn instance_poweroff_post(
    State(state): State<AppState>,
    jar: CookieJar,
    axum::extract::Path(instance_id): axum::extract::Path<String>,
) -> impl IntoResponse {
    if let Some(r) = ensure_logged_in(&state, &jar) {
        return r.into_response();
    }
    if !enforce_instance_access(&state, &jar, &instance_id).await {
        return Redirect::to("/instances").into_response();
    }
    if state.is_instance_disabled(&instance_id) {
        if let Some(sid) = jar.get("session_id") {
            let mut flashes = state.flash_store.lock().unwrap();
            let entry = flashes.entry(sid.value().to_string()).or_default();
            entry.push("Actions are disabled for this instance.".into());
        }
        return Redirect::to(&format!("/instance/{}", instance_id)).into_response();
    }
    let _ = simple_instance_action(&state, "poweroff", &instance_id).await;
    Redirect::to(&format!("/instance/{}", instance_id)).into_response()
}

// Render confirm page for reset
async fn instance_reset_get(
    State(state): State<AppState>,
    jar: CookieJar,
    axum::extract::Path(instance_id): axum::extract::Path<String>,
) -> impl IntoResponse {
    if let Some(r) = ensure_logged_in(&state, &jar) {
        return r.into_response();
    }
    if !enforce_instance_access(&state, &jar, &instance_id).await {
        return Redirect::to("/instances").into_response();
    }
    let endpoint = format!("/v1/instances/{}", instance_id);
    let payload = api_call(&state, "GET", &endpoint, None, None).await;
    let mut instance = InstanceForAction { id: instance_id.clone(), hostname: "(no hostname)".into(), region: "".into(), main_ip: None, status: "".into(), vcpu_count_display: "".into(), ram_display: "".into(), disk_display: "".into(), os: None };
    if let Some(obj) = payload.as_object() {
        if let Some(data) = obj.get("data").and_then(|d| d.as_object()) {
            instance.hostname = data.get("hostname").and_then(|v| v.as_str()).unwrap_or(&instance.hostname).to_string();
            instance.region = data.get("region").and_then(|v| v.as_str()).unwrap_or("").to_string();
            instance.main_ip = data.get("mainIp").and_then(|v| v.as_str()).map(|s| s.to_string());
            instance.status = data.get("status").and_then(|v| v.as_str()).unwrap_or("").to_string();
        }
    }
    let TemplateGlobals { current_user, api_hostname, base_url, flash_messages, has_flash_messages } = build_template_globals(&state, &jar);
    inject_context(&state, &jar, ResetInstanceTemplate { current_user, api_hostname, base_url, flash_messages, has_flash_messages, instance, is_disabled: state.is_instance_disabled(&instance_id) }.render().unwrap())
}

// POST handler for reset
async fn instance_reset_post(
    State(state): State<AppState>,
    jar: CookieJar,
    axum::extract::Path(instance_id): axum::extract::Path<String>,
) -> impl IntoResponse {
    if let Some(r) = ensure_logged_in(&state, &jar) {
        return r.into_response();
    }
    if !enforce_instance_access(&state, &jar, &instance_id).await {
        return Redirect::to("/instances").into_response();
    }
    if state.is_instance_disabled(&instance_id) {
        if let Some(sid) = jar.get("session_id") {
            let mut flashes = state.flash_store.lock().unwrap();
            let entry = flashes.entry(sid.value().to_string()).or_default();
            entry.push("Actions are disabled for this instance.".into());
        }
        return Redirect::to(&format!("/instance/{}", instance_id)).into_response();
    }
    let _ = simple_instance_action(&state, "reset", &instance_id).await;
    Redirect::to(&format!("/instance/{}", instance_id)).into_response()
}

// GET confirm page for change password
async fn instance_change_pass_get(
    State(state): State<AppState>,
    jar: CookieJar,
    axum::extract::Path(instance_id): axum::extract::Path<String>,
) -> impl IntoResponse {
    if let Some(r) = ensure_logged_in(&state, &jar) {
        return r.into_response();
    }
    if !enforce_instance_access(&state, &jar, &instance_id).await {
        return Redirect::to("/instances").into_response();
    }
    let endpoint = format!("/v1/instances/{}", instance_id);
    let payload = api_call(&state, "GET", &endpoint, None, None).await;
    let mut instance = InstanceForAction { id: instance_id.clone(), hostname: "(no hostname)".into(), region: "".into(), main_ip: None, status: "".into(), vcpu_count_display: "".into(), ram_display: "".into(), disk_display: "".into(), os: None };
    if let Some(obj) = payload.as_object() {
        if let Some(data) = obj.get("data").and_then(|d| d.as_object()) {
            instance.hostname = data.get("hostname").and_then(|v| v.as_str()).unwrap_or(&instance.hostname).to_string();
            instance.region = data.get("region").and_then(|v| v.as_str()).unwrap_or("").to_string();
            instance.main_ip = data.get("mainIp").and_then(|v| v.as_str()).map(|s| s.to_string());
            instance.status = data.get("status").and_then(|v| v.as_str()).unwrap_or("").to_string();
        }
    }
    let TemplateGlobals { current_user, api_hostname, base_url, flash_messages, has_flash_messages } = build_template_globals(&state, &jar);
    inject_context(&state, &jar, ChangePassInstanceTemplate { current_user, api_hostname, base_url, flash_messages, has_flash_messages, instance, new_password: None, is_disabled: state.is_instance_disabled(&instance_id) }.render().unwrap())
}

// POST handler for change-pass; display generated password in template
async fn instance_change_pass_post(
    State(state): State<AppState>,
    jar: CookieJar,
    axum::extract::Path(instance_id): axum::extract::Path<String>,
) -> impl IntoResponse {
    if let Some(r) = ensure_logged_in(&state, &jar) {
        return r.into_response();
    }
    if !enforce_instance_access(&state, &jar, &instance_id).await {
        return Redirect::to("/instances").into_response();
    }
    if state.is_instance_disabled(&instance_id) {
        if let Some(sid) = jar.get("session_id") {
            let mut flashes = state.flash_store.lock().unwrap();
            let entry = flashes.entry(sid.value().to_string()).or_default();
            entry.push("Actions are disabled for this instance.".into());
        }
        return Redirect::to(&format!("/instance/{}/change-pass", instance_id)).into_response();
    }
    let endpoint = format!("/v1/instances/{}/change-pass", instance_id);
    let payload = api_call(&state, "POST", &endpoint, None, None).await;
    let new_password = payload.get("data").and_then(|d| d.get("password")).and_then(|v| v.as_str()).map(|s| s.to_string());
    // Fetch instance details for rendering
    let get_endpoint = format!("/v1/instances/{}", instance_id);
    let payload2 = api_call(&state, "GET", &get_endpoint, None, None).await;
    let mut instance = InstanceForAction { id: instance_id.clone(), hostname: "(no hostname)".into(), region: "".into(), main_ip: None, status: "".into(), vcpu_count_display: "".into(), ram_display: "".into(), disk_display: "".into(), os: None };
    if let Some(obj) = payload2.as_object() {
        if let Some(data) = obj.get("data").and_then(|d| d.as_object()) {
            instance.hostname = data.get("hostname").and_then(|v| v.as_str()).unwrap_or(&instance.hostname).to_string();
            instance.region = data.get("region").and_then(|v| v.as_str()).unwrap_or("").to_string();
            instance.main_ip = data.get("mainIp").and_then(|v| v.as_str()).map(|s| s.to_string());
            instance.status = data.get("status").and_then(|v| v.as_str()).unwrap_or("").to_string();
        }
    }
    let TemplateGlobals { current_user, api_hostname, base_url, flash_messages, has_flash_messages } = build_template_globals(&state, &jar);
    inject_context(&state, &jar, ChangePassInstanceTemplate { current_user, api_hostname, base_url, flash_messages, has_flash_messages, instance, new_password, is_disabled: state.is_instance_disabled(&instance_id) }.render().unwrap())
}

async fn instance_delete(
    State(state): State<AppState>,
    jar: CookieJar,
    axum::extract::Path(instance_id): axum::extract::Path<String>,
) -> impl IntoResponse {
    if let Some(r) = ensure_logged_in(&state, &jar) {
        return r.into_response();
    }
    if !enforce_instance_access(&state, &jar, &instance_id).await {
        return Redirect::to("/instances").into_response();
    }
    if state.is_instance_disabled(&instance_id) {
        if let Some(sid) = jar.get("session_id") {
            let mut flashes = state.flash_store.lock().unwrap();
            let entry = flashes.entry(sid.value().to_string()).or_default();
            entry.push("Actions are disabled for this instance.".into());
        }
        return Redirect::to(&format!("/instance/{}", instance_id)).into_response();
    }
    let endpoint = format!("/v1/instances/{}", instance_id);
    let payload = api_call(&state, "DELETE", &endpoint, None, None).await;
    // Optionally set flash message for success or failure
    if let Some(sid) = jar.get("session_id") {
        let mut flashes = state.flash_store.lock().unwrap();
        let entry = flashes.entry(sid.value().to_string()).or_default();
        if payload.get("code").and_then(|c| c.as_str()) == Some("OKAY") {
            entry.push("Instance deleted successfully.".into());
            return Redirect::to("/instances").into_response();
        } else {
            let detail = payload.get("detail").and_then(|d| d.as_str()).unwrap_or("Unknown error");
            entry.push(format!("Delete failed: {}", detail));
            return Redirect::to(&format!("/instance/{}", instance_id)).into_response();
        }
    }
    // If no session-id in cookie, still redirect based on result
    if payload.get("code").and_then(|c| c.as_str()) == Some("OKAY") {
        Redirect::to("/instances").into_response()
    } else {
        Redirect::to(&format!("/instance/{}", instance_id)).into_response()
    }
}


async fn instance_add_traffic(
    State(state): State<AppState>,
    jar: CookieJar,
    axum::extract::Path(instance_id): axum::extract::Path<String>,
    Form(form): Form<AddTrafficForm>,
) -> impl IntoResponse {
    if !enforce_instance_access(&state, &jar, &instance_id).await {
        return Redirect::to("/instances").into_response();
    }
    if state.is_instance_disabled(&instance_id) {
        if let Some(sid) = jar.get("session_id") {
            let mut flashes = state.flash_store.lock().unwrap();
            let entry = flashes.entry(sid.value().to_string()).or_default();
            entry.push("Actions are disabled for this instance.".into());
        }
        return Redirect::to(&format!("/instance/{}", instance_id)).into_response();
    }
    if let Ok(amount) = form.traffic_amount.parse::<f64>() {
        if amount > 0.0 {
            let endpoint = format!("/v1/instances/{}/add-traffic", instance_id);
            let payload = serde_json::json!({"amount": amount});
            let _ = api_call(&state, "POST", &endpoint, Some(payload), None).await;
        }
    }
    Redirect::to(&format!("/instance/{}", instance_id)).into_response()
}


async fn instance_change_os_get(
    State(state): State<AppState>,
    jar: CookieJar,
    axum::extract::Path(instance_id): axum::extract::Path<String>,
) -> impl IntoResponse {
    if let Some(r) = ensure_logged_in(&state, &jar) {
        return r.into_response();
    }
    if !enforce_instance_access(&state, &jar, &instance_id).await {
        return Redirect::to("/instances").into_response();
    }
    let endpoint = format!("/v1/instances/{}", instance_id);
    let payload = api_call(&state, "GET", &endpoint, None, None).await;
    let mut instance = InstanceForAction { id: instance_id.clone(), hostname: "(no hostname)".into(), region: "".into(), main_ip: None, status: "".into(), vcpu_count_display: "".into(), ram_display: "".into(), disk_display: "".into(), os: None };
    if let Some(obj) = payload.as_object() {
        if let Some(data) = obj.get("data").and_then(|d| d.as_object()) {
            instance.hostname = data.get("hostname").and_then(|v| v.as_str()).unwrap_or(&instance.hostname).to_string();
            if let Some(os_obj) = data.get("os").and_then(|v| v.as_object()) {
                instance.os = Some(OsItem {
                    id: os_obj.get("id").and_then(|v| v.as_str()).unwrap_or("").to_string(),
                    name: os_obj.get("name").and_then(|v| v.as_str()).unwrap_or("").to_string(),
                    family: os_obj.get("family").and_then(|v| v.as_str()).unwrap_or("").to_string(),
                    arch: os_obj.get("arch").and_then(|v| v.as_str()).map(|s| s.to_string()),
                    min_ram: os_obj.get("minRam").and_then(|v| v.as_str()).map(|s| s.to_string()),
                    is_default: os_obj.get("isDefault").and_then(|v| v.as_bool()).unwrap_or(false),
                });
            }
            instance.region = data.get("region").and_then(|v| v.as_str()).unwrap_or("").to_string();
            instance.main_ip = data.get("mainIp").and_then(|v| v.as_str()).map(|s| s.to_string());
            instance.status = data.get("status").and_then(|v| v.as_str()).unwrap_or("").to_string();
        }
    }
    let os_list = load_os_list(&state).await;
    let TemplateGlobals { current_user, api_hostname, base_url, flash_messages, has_flash_messages } = build_template_globals(&state, &jar);
    inject_context(&state, &jar, ChangeOsTemplate { current_user, api_hostname, base_url, flash_messages, has_flash_messages, instance, os_list: &os_list, is_disabled: state.is_instance_disabled(&instance_id) }.render().unwrap())
}

async fn instance_change_os_post(
    State(state): State<AppState>,
    jar: CookieJar,
    axum::extract::Path(instance_id): axum::extract::Path<String>,
    Form(form): Form<ChangeOsForm>,
) -> impl IntoResponse {
    if let Some(r) = ensure_logged_in(&state, &jar) {
        return r.into_response();
    }
    if !enforce_instance_access(&state, &jar, &instance_id).await {
        return Redirect::to("/instances").into_response();
    }
    if state.is_instance_disabled(&instance_id) {
        if let Some(sid) = jar.get("session_id") {
            let mut flashes = state.flash_store.lock().unwrap();
            let entry = flashes.entry(sid.value().to_string()).or_default();
            entry.push("Actions are disabled for this instance.".into());
        }
        return Redirect::to(&format!("/instance/{}/change-os", instance_id)).into_response();
    }
    if form.os_id.trim().is_empty() {
        return Redirect::to(&format!("/instance/{}/change-os", instance_id)).into_response();
    }
    let endpoint = format!("/v1/instances/{}/change-os", instance_id);
    let payload = serde_json::json!({"osId": form.os_id});
    let _ = api_call(&state, "POST", &endpoint, Some(payload), None).await;
    Redirect::to(&format!("/instance/{}", instance_id)).into_response()
}


async fn instance_resize_get(
    State(state): State<AppState>,
    jar: CookieJar,
    axum::extract::Path(instance_id): axum::extract::Path<String>,
) -> impl IntoResponse {
    if let Some(r) = ensure_logged_in(&state, &jar) {
        return r.into_response();
    }
    if !enforce_instance_access(&state, &jar, &instance_id).await {
        return Redirect::to("/instances").into_response();
    }
    let endpoint = format!("/v1/instances/{}", instance_id);
    let payload = api_call(&state, "GET", &endpoint, None, None).await;
    let mut instance = InstanceForAction { id: instance_id.clone(), hostname: "(no hostname)".into(), region: "".into(), main_ip: None, status: "".into(), vcpu_count_display: "".into(), ram_display: "".into(), disk_display: "".into(), os: None };
    if let Some(obj) = payload.as_object() {
        if let Some(data) = obj.get("data").and_then(|d| d.as_object()) {
            instance.hostname = data.get("hostname").and_then(|v| v.as_str()).unwrap_or(&instance.hostname).to_string();
            instance.region = data.get("region").and_then(|v| v.as_str()).unwrap_or("").to_string();
            instance.main_ip = data.get("mainIp").and_then(|v| v.as_str()).map(|s| s.to_string());
            instance.status = data.get("status").and_then(|v| v.as_str()).unwrap_or("").to_string();
        }
    }
    let (regions, _map) = load_regions(&state).await;
    let TemplateGlobals { current_user, api_hostname, base_url, flash_messages, has_flash_messages } = build_template_globals(&state, &jar);
    inject_context(&state, &jar, ResizeTemplate { current_user, api_hostname, base_url, flash_messages, has_flash_messages, instance, regions: &regions, is_disabled: state.is_instance_disabled(&instance_id) }.render().unwrap())
}

async fn instance_resize_post(
    State(state): State<AppState>,
    jar: CookieJar,
    axum::extract::Path(instance_id): axum::extract::Path<String>,
    Form(form): Form<ResizeForm>,
) -> impl IntoResponse {
    if let Some(r) = ensure_logged_in(&state, &jar) {
        return r.into_response();
    }
    if !enforce_instance_access(&state, &jar, &instance_id).await {
        return Redirect::to("/instances").into_response();
    }
    if state.is_instance_disabled(&instance_id) {
        if let Some(sid) = jar.get("session_id") {
            let mut flashes = state.flash_store.lock().unwrap();
            let entry = flashes.entry(sid.value().to_string()).or_default();
            entry.push("Actions are disabled for this instance.".into());
        }
        return Redirect::to(&format!("/instance/{}/resize", instance_id)).into_response();
    }
    let endpoint = format!("/v1/instances/{}/resize", instance_id);
    let mut payload = serde_json::json!({"type": form.r#type});
    if form.r#type.to_uppercase() == "FIXED" {
        if let Some(pid) = form.product_id {
            payload["productId"] = Value::from(pid);
        }
    } else {
        let mut obj = serde_json::Map::new();
        if let Some(rid) = form.region_id { obj.insert("regionId".into(), Value::from(rid)); }
        if let Some(cpu) = form.cpu { if let Ok(n) = cpu.parse::<i64>() { obj.insert("cpu".into(), Value::from(n)); }}
        if let Some(ram) = form.ram_in_gb { if let Ok(n) = ram.parse::<i64>() { obj.insert("ramInGB".into(), Value::from(n)); }}
        if let Some(disk) = form.disk_in_gb { if let Ok(n) = disk.parse::<i64>() { obj.insert("diskInGB".into(), Value::from(n)); }}
        if let Some(bw) = form.bandwidth_in_tb { if let Ok(n) = bw.parse::<i64>() { obj.insert("bandwidthInTB".into(), Value::from(n)); }}
        if !obj.is_empty() {
            payload["resource"] = Value::Object(obj);
        }
    }
    let _ = api_call(&state, "POST", &endpoint, Some(payload), None).await;
    Redirect::to(&format!("/instance/{}", instance_id)).into_response()
}

// Subscription refund
async fn instance_subscription_refund(
    State(state): State<AppState>,
    jar: CookieJar,
    axum::extract::Path(instance_id): axum::extract::Path<String>,
) -> impl IntoResponse {
    if !enforce_instance_access(&state, &jar, &instance_id).await {
        return Redirect::to("/instances").into_response();
    }
    let endpoint = format!("/v1/instances/{}/subscription-refund", instance_id);
    let payload = api_call(&state, "GET", &endpoint, None, None).await;
    Html(format!("<html><body><h1>Refund {}</h1><pre>{}</pre><p><a href='/instance/{}'>Back</a></p></body></html>", instance_id, serde_json::to_string_pretty(&payload).unwrap_or("{}" .into()), instance_id)).into_response()
}

// Bulk subscription refund (owner)
// Bulk refund page is rendered via `templates/bulk_refund.html` (path-based Askama template)

#[derive(Deserialize)]
struct BulkRefundForm {
    ids: String,
}

async fn bulk_subscription_refund(
    State(state): State<AppState>,
    jar: CookieJar,
    Form(form): Form<BulkRefundForm>,
) -> impl IntoResponse {
    if let Some(r) = ensure_owner(&state, &jar) {
        return r.into_response();
    }
    let ids: Vec<String> = form
        .ids
        .split(',')
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty())
        .collect();
    let payload = serde_json::json!({"ids": ids});
    let resp = api_call(
        &state,
        "POST",
        "/v1/instances/bulk-subscription-refund",
        Some(payload),
        None,
    )
    .await;
    Html(format!("<html><body><h1>Bulk Refund Result</h1><pre>{}</pre><p><a href='/instances'>Back</a></p></body></html>", serde_json::to_string_pretty(&resp).unwrap_or("{}" .into()))).into_response()
}
async fn bulk_subscription_refund_get(
    State(state): State<AppState>,
    jar: CookieJar,
) -> impl IntoResponse {
    if let Some(r) = ensure_owner(&state, &jar) {
        return r.into_response();
    }
    let TemplateGlobals { current_user, api_hostname, base_url, flash_messages, has_flash_messages } = build_template_globals(&state, &jar);
    Html(
        BulkRefundTemplate {
            current_user,
            api_hostname,
            base_url,
            flash_messages,
            has_flash_messages,
        }
        .render()
        .unwrap(),
    )
    .into_response()
}

#[derive(Parser)]
#[command(
    name = "zy",
     author,
     version,
    about = "Zy command-line tool",
    long_about = r#"Zy  control and manage your Cloudzy services right from home.

This tool surfaces a small set of commands to run the server, validate configuration, manage local users and manage instances through the API. Use the `--env-file` option or environment variables to provide API credentials.

Examples:
  1) Build & run (dev):
      cargo run -- serve --host 127.0.0.1 --port 5000
  2) Build a release binary:
      cargo build --release
    3) Manage instances:
          zy instances list
          zy instances show 12345
"#, 
    after_help = "Use `zy <subcommand> --help` to get subcommand specific options and usage examples."
)]
struct Cli {
    #[command(subcommand)]
    command: Option<Commands>,
}

#[derive(Subcommand)]
enum Commands {
    /// Start the web server
    Serve {
        /// Host to bind to
        #[arg(long, default_value_t = String::from("0.0.0.0"))]
        host: String,
        /// Port to bind to
        #[arg(long, default_value_t = 5000)]
        port: u16,
        /// Path to .env file
        #[arg(long)]
        env_file: Option<String>,
    },
    /// Validate configuration (env vars / API credentials)
    #[command(about = "Validate configuration and ensure API connectivity.", long_about = "Validate environment variables required for the Zy server, and optionally validate the configured API token by attempting to fetch regions from the remote API.")]
    CheckConfig { env_file: Option<String> },
    /// Manage local users (users.json)
    Users {
        #[command(subcommand)]
        sub: UserCommands,
    },
    /// Manage instances via the configured API
    #[command(about = "Manage compute instances via the API (list, show, power, delete, etc.)", long_about = "These commands perform the same actions that the web UI's instance actions perform; they make API requests using the current API configuration and token. Be careful with commands that mutate state (delete, reset). Use `--help` on a subcommand for detailed examples.")]
    Instances {
        #[command(subcommand)]
        sub: InstanceCommands,
    },
}

#[derive(Subcommand)]
enum UserCommands {
    #[command(about = "List current users", long_about = "Enumerate users stored in users.json (username, role, assigned_instances).")]
    List,
    #[command(about = "Add a new user", long_about = "Add a user with a role (owner|admin). The password will be hashed and saved to users.json.")]
    Add {
        username: String,
        password: String,
        role: String,
    },
    /// Add a new owner user (use --force to overwrite existing owner user(s))
    #[command(about = "Add an owner user", long_about = "Create a new owner user. Use --force to overwrite an existing owner user or create another owner.")]
    AddOwner {
        username: String,
        password: String,
        #[arg(long, default_value_t = false)]
        force: bool,
    },
    #[command(about = "Reset a user's password", long_about = "Set a new password for an existing user; password will be hashed.")]
    ResetPassword {
        username: String,
        password: String,
    },
}

#[derive(Subcommand)]
enum InstanceCommands {
    /// List instances (optional --username to filter)
    #[command(about = "List instances", long_about = "List instances the configured API user may access. Provide `--username` to filter instances assigned to a local user.")]
    List {
        /// Optional username to filter instances by assigned user (use empty to list all)
        #[arg(long)]
        username: Option<String>,
    },
    /// Show instance details
    #[command(about = "Show instance details", long_about = "Show the raw JSON payload returned by the API for an instance ID.")]
    Show { instance_id: String },
    /// Power on an instance
    #[command(about = "Power on an instance", long_about = "Request an asynchronous power-on operation for an instance; the API may perform the action asynchronously.")]
    PowerOn { instance_id: String },
    /// Power off an instance
    #[command(about = "Power off an instance", long_about = "Request an asynchronous power-off operation for an instance; follow up with `show` to confirm state.")]
    PowerOff { instance_id: String },
    /// Reset an instance
    #[command(about = "Reset an instance", long_about = "Request an immediate reset/reboot of the instance. This is destructive to running state but usually preserves disks.")]
    Reset { instance_id: String },
    /// Delete an instance
    #[command(about = "Delete an instance", long_about = "Permanently delete an instance. Use with care and confirm `id` and `username` if necessary.")]
    Delete { instance_id: String },
    /// Change the instance password (prints the generated password)
    #[command(about = "Change root/console password", long_about = "Generate and set a new root/console password for an instance and print the generated value (if API returns it).")]
    ChangePass { instance_id: String },
    /// Change the instance OS
    #[command(about = "Change the instance OS", long_about = "Trigger an OS distribution and image change. Provide a valid `os_id` from the remote API.")]
    ChangeOs { instance_id: String, os_id: String },
    /// Resize the instance (type: FIXED|CUSTOM  for CUSTOM specify cpu,ram,disk etc.)
    #[command(about = "Resize an instance", long_about = "Change a plan; specify `--type FIXED` with `--product-id` or `--type CUSTOM` with specific resource values (cpu, ram-in-gb, disk-in-gb, bandwidth-in-tb).")]
    Resize { instance_id: String, #[arg(long)] r#type: String, #[arg(long)] product_id: Option<String>, #[arg(long)] cpu: Option<i64>, #[arg(long)] ram_in_gb: Option<i64>, #[arg(long)] disk_in_gb: Option<i64>, #[arg(long)] bandwidth_in_tb: Option<i64> },
    /// Add traffic amount (e.g., 50) to an instance
    #[command(about = "Add traffic to an instance", long_about = "Add additional traffic capacity to an instance using a numeric `--amount` (e.g., 50).")]
    AddTraffic { instance_id: String, amount: f64 },
    /// Trigger subscription refund (idempotent API query)
    #[command(about = "Request a subscription refund", long_about = "Trigger a subscription refund for an instance; results are returned as the API response and may contain success/failure codes.")]
    SubscriptionRefund { instance_id: String },
}

#[tokio::main]
async fn main() {
    // Initialize tracing
    tracing_subscriber::registry()
        .with(fmt::layer())
        .with(EnvFilter::from_default_env())
        .init();

    // CLI parsing
    let cli = Cli::parse();

    // If CLI provided an env-file or not, we will load it per command below
    // Build shared state (load users.json and env)
    let _user_store = {
        let path = std::path::Path::new("users.json");
        let mut map: HashMap<String, UserRecord> = HashMap::new();
        if path.exists() {
            if let Ok(text) = std::fs::read_to_string(path) {
                if let Ok(json_val) = serde_json::from_str::<serde_json::Value>(&text) {
                    if let Some(obj) = json_val.as_object() {
                        for (k, v) in obj.iter() {
                            if let Some(pw) = v.get("password").and_then(|x| x.as_str()) {
                                let role = v
                                    .get("role")
                                    .and_then(|x| x.as_str())
                                    .unwrap_or("admin")
                                    .to_string();
                                let assigned_instances = v
                                    .get("assigned_instances")
                                    .and_then(|a| a.as_array())
                                    .map(|arr| {
                                        arr.iter()
                                            .filter_map(|x| x.as_str().map(|s| s.to_string()))
                                            .collect()
                                    })
                                    .unwrap_or_else(|| vec![]);
                                map.insert(
                                    k.to_lowercase(),
                                    UserRecord {
                                        password: pw.to_string(),
                                        role,
                                        assigned_instances,
                                    },
                                );
                            }
                        }
                    }
                }
            }
        } else {
            // Create default owner
            // Generate werkzeug compatible hash for 'owner123' using pbkdf2 parameters
            let salt = {
                let mut b = [0u8; 12];
                OsRng.fill_bytes(&mut b);
                hex_encode(b)
            };
            let mut dk = [0u8; 32];
            pbkdf2_hmac::<Sha256>(b"owner123", salt.as_bytes(), PBKDF2_ITERATIONS, &mut dk);
            let hash_hex = hex_encode(dk);
            let full = format!("pbkdf2:sha256:{}${}${}", PBKDF2_ITERATIONS, salt, hash_hex);
            map.insert(
                "owner".to_string(),
                UserRecord {
                    password: full,
                    role: "owner".to_string(),
                    assigned_instances: vec![],
                },
            );
            let mut serialized: serde_json::Map<String, serde_json::Value> = serde_json::Map::new();
            for (u, rec) in map.iter() {
                serialized.insert(u.clone(), serde_json::json!({"password": rec.password, "role": rec.role, "assigned_instances": rec.assigned_instances }));
            }
            let _ = std::fs::write(
                path,
                serde_json::to_string_pretty(&serde_json::Value::Object(serialized)).unwrap(),
            );
        }
        Arc::new(Mutex::new(map))
    };

    // Note: we avoid constructing a default `state` here; commands build the per-command state
    // using `build_state_from_env` so we can pass a custom `--env-file` when executing commands.

    // Dispatch CLI commands. If no command provided, serve the web app by default
    if cli.command.is_none() {
        let state = build_state_from_env(None);
        start_server(state, DEFAULT_HOST, DEFAULT_PORT).await;
        return;
    }
    match cli.command.unwrap() {
        Commands::Serve {
            host,
            port,
            env_file,
        } => {
            let state = build_state_from_env(env_file.as_deref());
            start_server(state, &host, port).await;
            return;
        }
        Commands::CheckConfig { env_file } => {
            let state = build_state_from_env(env_file.as_deref());
            // Basic check: ensure API base and token exist; optionally ping regions
            let mut ok = true;
            if state.api_base_url.trim().is_empty() {
                eprintln!("API_BASE_URL is not configured");
                ok = false;
            }
            if state.api_token.trim().is_empty() {
                eprintln!("API_TOKEN is not configured");
                ok = false;
            }
            if !ok {
                process::exit(1);
            }
            let resp = api_call(&state, "GET", "/v1/regions", None, None).await;
            if resp.get("code").and_then(|c| c.as_str()) == Some("OKAY") {
                println!("Configuration looks valid (regions returned)");
                process::exit(0);
            } else {
                eprintln!(
                    "Configuration appears invalid: {}",
                    serde_json::to_string_pretty(&resp).unwrap_or_else(|_| "<non-json>".into())
                );
                process::exit(1);
            }
        }
        Commands::Users { sub } => {
            let state = build_state_from_env(None);
            match sub {
                UserCommands::List => {
                    let users = state.users.lock().unwrap();
                    println!("username\trole\tassigned_instances");
                    for (u, rec) in users.iter() {
                        let assigned = if rec.assigned_instances.is_empty() {
                            String::new()
                        } else {
                            rec.assigned_instances.join(", ")
                        };
                        println!("{}\t{}\t{}", u, rec.role, assigned);
                    }
                    return;
                }
                UserCommands::Add {
                    username,
                    password,
                    role,
                } => {
                    let uname = username.trim().to_lowercase();
                    let mut users = state.users.lock().unwrap();
                    if users.contains_key(&uname) {
                        eprintln!("User '{}' already exists", uname);
                        process::exit(1);
                    }
                    let hash = generate_password_hash(&password);
                    users.insert(
                        uname.clone(),
                        UserRecord {
                            password: hash,
                            role: role.clone(),
                            assigned_instances: vec![],
                        },
                    );
                    drop(users);
                    if let Err(e) = persist_users_file(&state.users) {
                        eprintln!("Failed to persist users.json: {}", e);
                        process::exit(1);
                    }
                    println!("User '{}' added", uname);
                    return;
                }
                UserCommands::ResetPassword { username, password } => {
                    let uname = username.trim().to_lowercase();
                    let mut users = state.users.lock().unwrap();
                    if let Some(rec) = users.get_mut(&uname) {
                        rec.password = generate_password_hash(&password);
                    } else {
                        eprintln!("User '{}' not found", uname);
                        process::exit(1);
                    }
                    drop(users);
                    if let Err(e) = persist_users_file(&state.users) {
                        eprintln!("Failed to persist users.json: {}", e);
                        process::exit(1);
                    }
                    println!("Password for '{}' updated", uname);
                    return;
                }
                UserCommands::AddOwner {
                    username,
                    password,
                    force,
                } => {
                    let uname = username.trim().to_lowercase();
                    let mut users = state.users.lock().unwrap();
                    // If an owner already exists and we're not forcing, error out
                    let owner_exists = users.values().any(|r| r.role == "owner");
                    if owner_exists && !force {
                        eprintln!(
                            "An owner user already exists; use --force to create another owner or overwrite"
                        );
                        process::exit(1);
                    }
                    // If the username exists and force is not set, fail (consistent with `Add` semantics)
                    if users.contains_key(&uname) && !force {
                        eprintln!("User '{}' already exists; use --force to overwrite", uname);
                        process::exit(1);
                    }
                    let hash = generate_password_hash(&password);
                    users.insert(
                        uname.clone(),
                        UserRecord {
                            password: hash,
                            role: "owner".to_string(),
                            assigned_instances: vec![],
                        },
                    );
                    drop(users);
                    if let Err(e) = persist_users_file(&state.users) {
                        eprintln!("Failed to persist users.json: {}", e);
                        process::exit(1);
                    }
                    println!("Owner '{}' created", uname);
                    return;
                }
            }
        }
        Commands::Instances { sub } => {
            let state = build_state_from_env(None);
            match sub {
                InstanceCommands::List { username } => {
                    let uname = username.unwrap_or_default();
                    let list = load_instances_for_user(&state, &uname).await;
                    println!("id\thostname\tstatus");
                    for i in list {
                        println!("{}\t{}\t{}", i.id, i.hostname, i.status);
                    }
                    return;
                }
                InstanceCommands::Show { instance_id } => {
                    let endpoint = format!("/v1/instances/{}", instance_id);
                    let payload = api_call(&state, "GET", &endpoint, None, None).await;
                    println!("{}", serde_json::to_string_pretty(&payload).unwrap_or_else(|_| "<non-json>".into()));
                    return;
                }
                InstanceCommands::PowerOn { instance_id } => {
                    let payload = simple_instance_action(&state, "poweron", &instance_id).await;
                    println!("{}", serde_json::to_string_pretty(&payload).unwrap_or_else(|_| "<non-json>".into()));
                    return;
                }
                InstanceCommands::PowerOff { instance_id } => {
                    let payload = simple_instance_action(&state, "poweroff", &instance_id).await;
                    println!("{}", serde_json::to_string_pretty(&payload).unwrap_or_else(|_| "<non-json>".into()));
                    return;
                }
                InstanceCommands::Reset { instance_id } => {
                    let payload = simple_instance_action(&state, "reset", &instance_id).await;
                    println!("{}", serde_json::to_string_pretty(&payload).unwrap_or_else(|_| "<non-json>".into()));
                    return;
                }
                InstanceCommands::Delete { instance_id } => {
                    let endpoint = format!("/v1/instances/{}", instance_id);
                    let payload = api_call(&state, "DELETE", &endpoint, None, None).await;
                    println!("{}", serde_json::to_string_pretty(&payload).unwrap_or_else(|_| "<non-json>".into()));
                    return;
                }
                InstanceCommands::ChangePass { instance_id } => {
                    let endpoint = format!("/v1/instances/{}/change-pass", instance_id);
                    let payload = api_call(&state, "POST", &endpoint, None, None).await;
                    if let Some(pass) = payload.get("data").and_then(|d| d.get("password")).and_then(|v| v.as_str()) {
                        println!("New password for {}: {}", instance_id, pass);
                    } else {
                        println!("{}", serde_json::to_string_pretty(&payload).unwrap_or_else(|_| "<non-json>".into()));
                    }
                    return;
                }
                InstanceCommands::ChangeOs { instance_id, os_id } => {
                    let endpoint = format!("/v1/instances/{}/change-os", instance_id);
                    let payload = serde_json::json!({"osId": os_id});
                    let resp = api_call(&state, "POST", &endpoint, Some(payload), None).await;
                    println!("{}", serde_json::to_string_pretty(&resp).unwrap_or_else(|_| "<non-json>".into()));
                    return;
                }
                InstanceCommands::Resize { instance_id, r#type, product_id, cpu, ram_in_gb, disk_in_gb, bandwidth_in_tb } => {
                    let endpoint = format!("/v1/instances/{}/resize", instance_id);
                    let mut payload = serde_json::json!({"type": r#type});
                    if payload.get("type").and_then(|t| t.as_str()).unwrap_or("") == "FIXED" {
                        if let Some(pid) = product_id {
                            payload["productId"] = serde_json::Value::from(pid);
                        }
                    } else {
                        let mut obj = serde_json::Map::new();
                        if let Some(cpu) = cpu { obj.insert("cpu".into(), serde_json::Value::from(cpu)); }
                        if let Some(ram) = ram_in_gb { obj.insert("ramInGB".into(), serde_json::Value::from(ram)); }
                        if let Some(disk) = disk_in_gb { obj.insert("diskInGB".into(), serde_json::Value::from(disk)); }
                        if let Some(bw) = bandwidth_in_tb { obj.insert("bandwidthInTB".into(), serde_json::Value::from(bw)); }
                        if !obj.is_empty() { payload["resource"] = serde_json::Value::Object(obj); }
                    }
                    let resp = api_call(&state, "POST", &endpoint, Some(payload), None).await;
                    println!("{}", serde_json::to_string_pretty(&resp).unwrap_or_else(|_| "<non-json>".into()));
                    return;
                }
                InstanceCommands::AddTraffic { instance_id, amount } => {
                    let endpoint = format!("/v1/instances/{}/add-traffic", instance_id);
                    let payload = serde_json::json!({"amount": amount});
                    let resp = api_call(&state, "POST", &endpoint, Some(payload), None).await;
                    println!("{}", serde_json::to_string_pretty(&resp).unwrap_or_else(|_| "<non-json>".into()));
                    return;
                }
                InstanceCommands::SubscriptionRefund { instance_id } => {
                    let endpoint = format!("/v1/instances/{}/subscription-refund", instance_id);
                    let resp = api_call(&state, "GET", &endpoint, None, None).await;
                    println!("{}", serde_json::to_string_pretty(&resp).unwrap_or_else(|_| "<non-json>".into()));
                    return;
                }
            }
        }
    }

    // All command arms either `return` or `process::exit`; nothing else to do here

    // (start_server handles starting the http listener)
}
